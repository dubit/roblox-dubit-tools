--[[
	Event:
]]
--

local Signal = require(script.Parent.Parent.Signal)

local Timer = require(script.Parent.Timer)
local UTC = require(script.Parent.UTC)

--[=[
	@class Event

	The 'Event' class is the primary class developers will interact with, it's job is to manipulate the logic for a live event.
]=]
local Event = {}

Event.type = "Event"

Event.internal = {}
Event.instances = {}
Event.interface = {}

Event.prototype = {}

Event.interface.EventActivated = Signal.new()
Event.interface.EventDeactivated = Signal.new()

--[=[
	This lifecycle function is called when the event is first activated.

	:::caution
		Aim to perform synchronous operations inside of lifecycle methods
	:::

	@method OnActivated
	@within Event

	@return ()
]=]
--

--[=[
	This lifecycle function is called when the event has expired.

	:::caution
		Aim to perform synchronous operations inside of lifecycle methods
	:::

	@method OnDeactivated
	@within Event

	@return ()
]=]
--

--[[
	This function is a developer QoL function used to execute methods inside of an 'Event' object.
]]
--
function Event.internal:InvokeLifecycleMethod(object, methodName, ...)
	if not object[methodName] then
		return
	end

	return object[methodName](object, ...)
end

--[=[
	This function will update the Timers generated by this event.

	@method UpdateTimers
	@within Event

	@return ()
]=]
--
function Event.prototype:UpdateTimers()
	if not self.UTCStartTime or not self.UTCEndTime then
		return
	end

	if not self._timersEnabled then
		return
	end

	if self:GetState() then
		if self.StartTimer:IsExpired() then
			if self.EndTimer:IsExpired() then
				self:SetState(false)
				self:UpdateTimers()
			end
		else
			self:SetState(false)
			self:UpdateTimers()
		end
	else
		if self.StartTimer:IsExpired() and not self.EndTimer:IsExpired() then
			self:SetState(true)
			self:UpdateTimers()
		end
	end
end

--[=[
	This function will disable the logic for updating timers, developers may want to do this in the case they want to manually start or stop an event without timers taking precedence over event state

	@method DisableTimerUpdates
	@within Event

	@return ()
]=]
--
function Event.prototype:DisableTimerUpdates()
	self._timersEnabled = false
end

--[=[
	This function will enable the logic for updating timers

	@method EnableTimerUpdates
	@within Event

	@return ()
]=]
--
function Event.prototype:EnableTimerUpdates()
	self._timersEnabled = true
end

--[=[
	This function will set the state of an event, this is typically handled internally but is exposed for developer debugging.

	@method SetState
	@within Event

	@param state boolean

	@return ()
]=]
--
function Event.prototype:SetState(state)
	if self._state == state then
		return
	end

	self._state = state

	if state then
		self.Activated:Fire()

		Event.interface.EventActivated:Fire(self)
		Event.internal:InvokeLifecycleMethod(self, "OnActivated")
	else
		self.Deactivated:Fire()

		Event.interface.EventDeactivated:Fire(self)
		Event.internal:InvokeLifecycleMethod(self, "OnDeactivated")
	end
end

--[=[
	This function will return the state of an event, if this state is 'true' then the event is active.

	@method GetState
	@within Event

	@return boolean
]=]
--
function Event.prototype:GetState()
	return self._state or false
end

--[=[
	This function will return the amount of seconds before the start of an event.

	@method GetTimeUntilStart
	@within Event

	@return number
]=]
--
function Event.prototype:GetTimeUntilStart()
	assert(self.StartTimer ~= nil, `Expected 'UTCStartTime' to be specified in the {self.Label} event`)

	-- self:UpdateTimers()

	return self.StartTimer:GetDeltaTime()
end

--[=[
	This function will return the amount of seconds before the end of an event.

	@method GetTimeUntilEnd
	@within Event

	@return number
]=]
--
function Event.prototype:GetTimeUntilEnd()
	assert(self.EndTimer ~= nil, `Expected 'UTCEndTime' to be specified in the {self.Label} event`)

	-- self:UpdateTimers()

	return self.EndTimer:GetDeltaTime()
end

--[=[
	This function will return a boolean depending if this event has time constraints

	@method IsTracked
	@within Event

	@return boolean
]=]
--
function Event.prototype:IsTracked()
	return self.EndTimer and self.StartTimer
end

--[=[
	This function generates a string that shows the following; Event Type, Event Label

	@method ToString
	@within Event

	@return string
]=]
--
function Event.prototype:ToString()
	return `{Event.type}<"{self.Label}">`
end

--[=[
	This function will cleanup any connections the Event has made in it's lifetime.

	@method Destroy
	@within Event

	@return ()
]=]
--
function Event.prototype:Destroy()
	for _, connection in self._connections do
		connection:Disconnect()
	end

	Event.instances[self.Label] = nil
end

--[=[
	This function constructs a new 'Event' class

	@function new
	@within Event

	@param name string
	@param data {UTCStartTime: UTC?, UTCEndTime: UTC?}

	@return Event
]=]
--
function Event.interface.new(name, data)
	assert(type(name) == "string", `Expected 'Name' field to be a string, got {type(name)}`)
	assert(type(data) == "table", `Expected 'data' field to be a table, got {type(name)}`)

	assert(Event.instances[name] == nil, `Expected 'name' to be unique, the name given has already been registered`)

	--[=[
		@prop Label string
		@within Event
	]=]
	--
	data.Label = name

	--[=[
		@prop Activated Signal
		@within Event
	]=]
	--
	data.Activated = Signal.new()

	--[=[
		@prop Deactivated Signal
		@within Event
	]=]
	--
	data.Deactivated = Signal.new()

	data._connections = {}
	data._timersEnabled = true

	local self = setmetatable(data, {
		__type = Event.type,
		__index = Event.prototype,
		__tostring = function(obj)
			return obj:ToString()
		end,
	})

	--[=[
		@prop UTCStartTime? UTC?
		@within Event
	]=]
	--

	--[=[
		@prop StartTimer? Timer?
		@within Event
	]=]
	--

	--[=[
		@prop UTCEndTime? UTC?
		@within Event
	]=]
	--

	--[=[
		@prop EndTimer? Timer?
		@within Event
	]=]
	--

	if self.UTCStartTime or self.UTCEndTime then
		assert(
			UTC.is(self.UTCStartTime),
			`Expected 'UTCStartTime' to be a 'UTC' object, got {typeof(self.UTCStartTime)}`
		)
		assert(UTC.is(self.UTCEndTime), `Expected 'UTCEndTime' to be a 'UTC' object, got {typeof(self.UTCEndTime)}`)
		assert(
			self.UTCStartTime:GetEpochTime() ~= self.UTCEndTime:GetEpochTime(),
			"Both 'UTCStartTime' & 'UTCEndTime' share the same time, an event have the length of 0 seconds."
		)

		self.StartTimer = Timer.new(self.UTCStartTime)
		self.EndTimer = Timer.new(self.UTCEndTime)

		task.defer(function()
			self:UpdateTimers()
		end)
	end

	Event.instances[name] = self
	return Event.instances[name]
end

--[=[
	This function compares the first parameter to the 'Event' class

	@function is
	@within Event

	@param object? Event?
	@return boolean
]=]
--
function Event.interface.is(object)
	if typeof(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	return objectMetatable and objectMetatable.__type == Event.type
end

--[=[
	Retrieve an array of 'Event' objects.

	@function get
	@within Event
	@private

	@return { Event }
]=]
--
function Event.interface.getAll()
	return Event.instances
end

--[=[
	Retrieve an 'Event' object through it's label.

	@function get
	@within Event
	@private

	@param name string

	@return Event | nil
]=]
--
function Event.interface.get(name)
	return Event.instances[name]
end

return Event.interface
