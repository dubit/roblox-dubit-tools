{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Getting Started","text":"<p>Welcome, this is the Roblox Dubit Tools (RDT) documentation site for Packages developed by Dubit.</p>"},{"location":"api/allocation_pool/","title":"API","text":""},{"location":"api/allocation_pool/#properties","title":"Properties","text":""},{"location":"api/allocation_pool/#budgetconsumed","title":"BudgetConsumed","text":"<pre><code>AllocationPool.BudgetConsumed: Signal&lt;string, number&gt;\n</code></pre>"},{"location":"api/allocation_pool/#budgetfailed","title":"BudgetFailed","text":"<pre><code>AllocationPool.BudgetFailed: Signal&lt;string, string&gt;\n</code></pre>"},{"location":"api/allocation_pool/#functions","title":"Functions","text":""},{"location":"api/allocation_pool/#consumepoolasync","title":".ConsumePoolAsync","text":"<pre><code>AllocationPool.ConsumePoolAsync(player: Player?, poolName: string, size: number?): Promise\n</code></pre> <p>Consumes a pool allocation for a player. This function updates both the player's consumed pools list and the pool's consumption count. The operation is performed asynchronously and returns a promise that resolves when complete.</p> <p>If a player is provided, it will mark the pool as consumed for that player before attempting to consume from the pool. The size parameter determines how many allocations to consume from the pool, defaulting to 1 if not specified.</p> <p>Warning</p> <p>This promise can reject if the pool is already consumed by the player or if the pool has reached its limit. Implement error handling to handle these scenarios.</p> <p>This function will not error if the pool is already consumed by the player. You need to handle this scenario in your code.</p> <pre><code>AllocationPool.ConsumePoolAsync(player, poolName):andThen(function()\n    awardUgc(player)\nend):catch(function(err)\n    warn(err)\nend)\n\n-- or in the event you'd like to consume a budget anonymously\n\nAllocationPool.ConsumePoolAsync(nil, poolName):andThen(function()\n    awardUgc(player)\nend):catch(function(err)\n    warn(err)\nend)\n</code></pre>"},{"location":"api/allocation_pool/#createpoolasync","title":".CreatePoolAsync","text":"<pre><code>AllocationPool.CreatePoolAsync(poolName: string, poolLimit: number): ()\n</code></pre> <p>Creates a new allocation pool with the specified name and limit.</p> <p>This function creates a new allocation pool in the datastore with the given name and maximum allocation limit. If a pool with the same name already exists, it will update the limit if different from the provided value.</p> <pre><code>AllocationPool.CreatePoolAsync(\"MyPool\", 10):expect()\n</code></pre>"},{"location":"api/allocation_pool/#getpoolcountasync","title":".GetPoolCountAsync","text":"<pre><code>AllocationPool.GetPoolCountAsync(poolName: string): Promise\n</code></pre> <p>Returns the current consumption count for a specific pool.</p> <p>This function retrieves the pool's data from the datastore and returns a promise that resolves with the number of allocations consumed from the pool.</p> <pre><code>local poolCount = AllocationPool.GetPoolCountAsync(\"MyPool\"):expect()\n</code></pre>"},{"location":"api/allocation_pool/#getpoollimitasync","title":".GetPoolLimitAsync","text":"<pre><code>AllocationPool.GetPoolLimitAsync(poolName: string): Promise\n</code></pre> <p>Returns the pool's limit value from the datastore.</p> <p>This function retrieves the pool's data and returns a promise that resolves with the maximum number of allocations allowed for the specified pool.</p> <pre><code>local poolLimit = AllocationPool.GetPoolLimitAsync(\"MyPool\"):expect()\n</code></pre>"},{"location":"api/allocation_pool/#getpoolreserveasync","title":".GetPoolReserveAsync","text":"<pre><code>AllocationPool.GetPoolReserveAsync(poolName: string): Promise\n</code></pre> <p>Returns the remaining allocations available in a pool.</p> <p>This function retrieves the pool's data from the datastore and calculates the difference between the pool's limit and current consumption count. The result represents how many more allocations can be made from the pool.</p> <pre><code>local lastPoolValue = AllocationPool.GetPoolReserveAsync(\"PreviousPool\"):expect()\nlocal newPoolValue = AllocationPool.CreatePool(\"NewPool\", DEFAULT_POOL_LIMIT + lastPoolValue):expect()\n</code></pre>"},{"location":"api/allocation_pool/#hasconsumedasync","title":".HasConsumedAsync","text":"<pre><code>AllocationPool.HasConsumedAsync(player: Player, poolName: string): Promise\n</code></pre> <p>Checks if a player has consumed a specific pool in the datastore.</p> <p>This function queries the player's consumed pools list to determine if the specified pool name exists.</p> <p>The operation is performed asynchronously and returns a promise that resolves with a boolean indicating consumption status.</p> <pre><code>local hasConsumed = AllocationPool.HasConsumedAsync(player, poolName):expect()\n</code></pre>"},{"location":"api/allocation_pool/#markconsumedasync","title":".MarkConsumedAsync","text":"<pre><code>AllocationPool.MarkConsumedAsync(player: Player, poolName: string): Promise\n</code></pre> <p>Marks a pool as consumed for a player in the datastore.</p> <p>This function updates the player's consumed pools list by adding the specified pool name. The operation is performed asynchronously and returns a promise that resolves when complete.</p> <pre><code>AllocationPool.MarkConsumedAsync(player, poolName):expect()\n</code></pre>"},{"location":"api/allocation_pool/#resetpoolasync","title":".ResetPoolAsync","text":"<pre><code>AllocationPool.ResetPoolAsync(poolName: string): Promise\n</code></pre> <p>Resets a pool's consumption count back to zero.</p> <p>This function updates the pool's consumption count in the datastore and returns a promise that resolves when complete.</p> <p>This is useful for resetting pool allocations after a specific event or time period.</p> <pre><code>AllocationPool.ResetPoolAsync(player, poolName)\n</code></pre>"},{"location":"api/allocation_pool/#resetconsumedasync","title":".ResetConsumedAsync","text":"<pre><code>AllocationPool.ResetConsumedAsync(player: Player, poolName: string?): Promise\n</code></pre> <p>Will remove the users data from allocation pools datastore</p> <p>If the second parameter 'PoolName' is given, this function will remove all references to the pool name given. If the second parameter 'PoolName' is not given, this function will remove all pools from the users pools consumption.</p> <pre><code>AllocationPool.ResetConsumedAsync(player, poolName):expect()\n</code></pre>"},{"location":"api/allocation_pool/#updatepoollimitasync","title":".UpdatePoolLimitAsync","text":"<pre><code>AllocationPool.UpdatePoolLimitAsync(poolName: string, poolLimit: number): ()\n</code></pre> <p>Updates the pool's limit value in the datastore.</p> <p>This function updates the pool's maximum allocation limit in the datastore. The new limit will be applied immediately and affects future allocation attempts.</p> <pre><code>AllocationPool.UpdatePoolLimitAsync(\"MyPool\", 10):expect()\n</code></pre>"},{"location":"api/allocation_pool/#initialize","title":".Initialize","text":"<pre><code>AllocationPool.Initialize(): ()\n</code></pre> <p>Initializes the AllocationPool service and starts the pool synchronization loop.</p> <p>This function sets up player cleanup and continuously updates pool consumption while managing budget limits.</p>"},{"location":"api/anticheat/","title":"API","text":""},{"location":"api/anticheat/#properties","title":"Properties","text":""},{"location":"api/anticheat/#cheaterfound","title":"CheaterFound","text":"<pre><code>AntiCheat.CheaterFound: Signal&lt;Player&gt;\n</code></pre> <p>Invoked when the anti-cheat determines a player is cheating</p> <pre><code>AntiCheat.CheaterFound:Connect(function(player)\n    Players:BanAsync({\n        UserIds = { player.UserId },\n        DisplayReason = \"\\\"There is no right and wrong. There's only fun and boring.\\\" ~ Hackers\"\n    })\nend)\n</code></pre>"},{"location":"api/anticheat/#violationtriggered","title":"ViolationTriggered","text":"<pre><code>AntiCheat.ViolationTriggered: Signal&lt;Player, string, string&gt;\n</code></pre> <p>Warning</p> <p>This signal should not be used to detect cheaters. Use the CheaterFound signal instead!</p> <p>Invoked when a player triggers a rule violation, increasing their anti-cheat score.</p> <pre><code>AntiCheat.ViolationTriggered:Connect(function(player, node, message)\n    print(`Player {player.Name} has violated node '{node}': '{message}'`)\nend)\n</code></pre>"},{"location":"api/anticheat/#nodes","title":"Nodes","text":"<pre><code>AntiCheat.Nodes: { [string]: { any } }\n</code></pre> <p>Table denotating the different nodes that this version of the AntiCheat supports, you can pass these nodes directly into the APIs that require NodeTable.</p> <p>Nodes represent the fundamental building blocks of the Anticheat system. Each node defines a specific feature or functionality.</p> <p>Currently available keys:</p> <ul> <li>ProximityPrompt</li> <li>Honeypot</li> <li>AntiClimb</li> <li>AntiSwim</li> <li>AntiFly</li> <li>AntiNoclip</li> <li>AntiSpeed</li> </ul>"},{"location":"api/anticheat/#methods","title":"Methods","text":""},{"location":"api/anticheat/#addtowhitelist","title":":AddToWhitelist","text":"<pre><code>AntiCheat:AddToWhitelist(player: Player): ()\n</code></pre> <p>Adds a player to the whitelist. Whitelisted players are exempt from anti-cheat monitoring and can freely bypass restrictions.</p> <p>This is a server only method.</p>"},{"location":"api/anticheat/#disable","title":":Disable","text":"<pre><code>AntiCheat:Disable(): ()\n</code></pre> <p>Disables the anti-cheat. When this method is called, all detection nodes are stopped, meaning players will no longer be monitored.</p> <p>This is a server only method.</p>"},{"location":"api/anticheat/#disablenode","title":":DisableNode","text":"<pre><code>AntiCheat:Disable(node: string | NodeTable): ()\n</code></pre> <p>Disables a specific \"node\" of the AntiCheat.</p> <p>To further explain what a Node is - the anticheat is broken up into several parts, each play their own role in identifying potential exploiters, and then getting them detected.</p> <p>Developers have the ability to disable/enable different nodes in the event the Noclip detection is currently acting up and we may not have the time to address the issues with it.</p> <pre><code>AntiCheat:DisableNode(AntiCheat.AntiFly)\nAntiCheat:DisableNode(\"AntiFly\")\n</code></pre> <p>This is a server only method.</p>"},{"location":"api/anticheat/#enable","title":":Enable","text":"<pre><code>AntiCheat:Enable(): ()\n</code></pre> <p>Enables the anti-cheat. This should only be called if the anti-cheat has been previously disabled using the :Disable method.</p> <p>This is a server only method.</p>"},{"location":"api/anticheat/#enablenode","title":":EnableNode","text":"<pre><code>AntiCheat:EnableNode(node: string | NodeTable) \u2192 ()\n</code></pre> <p>Enables a specific \"node\" of the AntiCheat.</p> <p>To further explain what a Node is - the anticheat is broken up into several parts, each play their own role in identifying potential exploiters, and then getting them detected.</p> <p>Developers have the ability to disable/enable different nodes in the event the Noclip detection is currently acting up and we may not have the time to address the issues with it.</p> <pre><code>AntiCheat:EnableNode(AntiCheat.AntiFly)\nAntiCheat:EnableNode(\"AntiFly\")\n</code></pre> <p>This is a server only method.</p>"},{"location":"api/anticheat/#flagascheater","title":":FlagAsCheater","text":"<pre><code>AntiCheat:FlagAsCheater(player: Player): ()\n</code></pre> <p>Flags a player as a cheater. This information is stored in a datastore, managed entirely by the anti-cheat system.</p> <p>Warning</p> <p>This function is automatically called when a player is detected as a cheater. See CheaterFound for more details.</p> <p>This is a server only method.</p>"},{"location":"api/anticheat/#isflaggedascheater","title":":IsFlaggedAsCheater","text":"<pre><code>AntiCheat:IsFlaggedAsCheater(player: Player): boolean\n</code></pre> <p>Allows developers on both the client, and the server - to query if the current player is a cheater or not.</p>"},{"location":"api/anticheat/#queryscores","title":":QueryScores","text":"<pre><code>AntiCheat:QueryScores(player: Player): { [string]: number }\n</code></pre> <p>Allows developers to query the current players score for all nodes. Score indicates how likely that player is to be a cheater, it's not a direct indication that these players are cheaters.</p> <p>This is a server only method.</p>"},{"location":"api/anticheat/#queryviolations","title":":QueryViolations","text":"<pre><code>AntiCheat:QueryViolations(player: Player): { [string]: {string} }\n</code></pre> <p>Allows developers to query a list of violations that the current player has broken, this list includes messages explaining what has gone wrong and information about the event.</p> <p>This list is broken up to allow developers to see what specific nodes a player has violated, then the messages are bundled under each node.</p> <p>This is a server only method.</p>"},{"location":"api/anticheat/#removefromwhitelist","title":":RemoveFromWhitelist","text":"<pre><code>AntiCheat:RemoveFromWhitelist(player: Player): ()\n</code></pre> <p>Removes a player from the whitelist. See AddToWhitelist for details.</p> <p>This is a server only method.</p>"},{"location":"api/anticheat/#resetflag","title":":ResetFlag","text":"<pre><code>AntiCheat:ResetFlag(path: string): ()\n</code></pre> <p>Will reset the flag to whatever it is by default, this allows developers to safely fallback to the defaults without having to create references for each flag before hand.</p> <pre><code>AntiCheat:ResetFlag(AntiCheat.AntiFly.RaycastDistance)\n</code></pre> <p>This is a server only method.</p>"},{"location":"api/anticheat/#setflag","title":":SetFlag","text":"<pre><code>AntiCheat:SetFlag(path: string, value: any): ()\n</code></pre> <p>Allows developers to configure specific flags the anticheat, and all nodes under it uses to identify and detect potential exploiters.</p> <p>Be careful when modifying these flags, we should try to optimise the default flags over having different flags defined per project.</p> <pre><code>AntiCheat:SetFlag(AntiCheat.AntiFly.RaycastDistance, 1.5)\n\n-- alternatively, if you know what these are called internally, you can use the name of the path you're writing\n-- to instead.\nAntiCheat:EnableNode(\"AntiFlyRaycastDistance\")\n</code></pre> <p>This is a server only method.</p>"},{"location":"api/anticheat/#setverbose","title":":SetVerbose","text":"<pre><code>AntiCheat:SetVerbose(isVerbose: boolean): ()\n</code></pre> <p>Enables or disables debug warnings in the Output. By default, this is set to false.</p> <p>Warnings indicate when a player has violated a node's rules, allowing developers to diagnose unintended behavior (e.g., a player being teleported back after a script-triggered teleport).</p> <p>This is a server only method.</p>"},{"location":"api/anticheat/#waituntilready","title":":WaitUntilReady","text":"<pre><code>AntiCheat:WaitUntilReady(): ()\n</code></pre> <p>Will yield the current thread until the whitelist has marked itself as ready on parallel luau, because the anticheat works by sending messages through bindable events - we need to make sure the other side (parallel luau) is set up before we start emitting events.</p> <p>This is a server only method.</p>"},{"location":"api/anticheat/#initializedesyncluau","title":":InitializeDesyncLuau","text":"<pre><code>AntiCheat:InitializeDesyncLuau(): ()\n</code></pre> <p>Responsible for initialising the library in parallel luau.</p>"},{"location":"api/anticheat/#initializesyncluau","title":":InitializeSyncLuau","text":"<pre><code>AntiCheat:InitializeSyncLuau(): ()\n</code></pre> <p>Responsible for initialising the library.</p> <p>Warning</p> <p>This function is called automatically when experience starts.</p>"},{"location":"api/bolt/","title":"API","text":""},{"location":"api/bolt/#bolt","title":"Bolt","text":""},{"location":"api/bolt/#functions","title":"Functions","text":""},{"location":"api/bolt/#reliableevent","title":".ReliableEvent","text":"<pre><code>Bolt.ReliableEvent&lt;T...&gt;(eventName: string, serializer: ((writer: BufferWriter, T...) -&gt; ())?, deserializer: ((reader: BufferReader) -&gt; T...)?): ReliableEvent&lt;T...&gt;\n</code></pre> <p>Creates a ReliableEvent that is used for communication between client &lt;-&gt; server with a guaranteed delivery on both sides.</p>"},{"location":"api/bolt/#remoteproperty","title":".RemoteProperty","text":"<pre><code>Bolt.RemoteProperty&lt;T&gt;(propertyName: string, defaultValue: T, serializer: ((writer: BufferWriter, T) -&gt; ())?, deserializer: ((reader: BufferReader) -&gt; T)?): RemoteProperty&lt;T&gt;\n</code></pre> <p>Creates a RemoteProperty that automatically synchronizes its value to Players.</p>"},{"location":"api/bolt/#remotefunction","title":".RemoteFunction","text":"<pre><code>Bolt.RemoteFunction&lt;T..., R...&gt;(functionName: string): RemoteFunction&lt;T..., R...&gt;\n</code></pre> <p>Creates a RemoteFunction that allows for clients to execute server functions just like they would do on the client side. The code invoking the function yields until it receives a response from the server.</p> <p>Warning</p> <p>Bolt doesn't allow for server to client remote function calls as it's a security risk that's not worth the convinience.</p>"},{"location":"api/bolt/#reliableevent_1","title":"ReliableEvent","text":""},{"location":"api/bolt/#properties","title":"Properties","text":""},{"location":"api/bolt/#onclientevent","title":"OnClientEvent","text":"<pre><code>ReliableEvent.OnClientEvent: RestrictedConnector&lt;T...&gt;\n</code></pre> <p>Fires on client side when the server sends an event.</p>"},{"location":"api/bolt/#onserverevent","title":"OnServerEvent","text":"<pre><code>ReliableEvent.OnServerEvent: RestrictedConnector&lt;Player, T...&gt;\n</code></pre> <p>Fires on server side when the client sends an event.</p>"},{"location":"api/bolt/#functions_1","title":"Functions","text":""},{"location":"api/bolt/#fireserver","title":":FireServer","text":"<pre><code>ReliableEvent:FireServer(...: T...): ()\n</code></pre> <p>Fires the OnServerEvent event on the server from one client. Connected events receive the Player argument of the firing client. Since this method is used to communicate from a client to the server, it only works when used in a client script.</p> <p>Warning</p> <p>This property can be only called from client scripts.</p>"},{"location":"api/bolt/#fireclient","title":":FireClient","text":"<pre><code>ReliableEvent:FireClient(player: Player, ...: T...): ()\n</code></pre> <p>Fires the OnClientEvent event for the specific client in the required Player argument. Since this method is used to communicate from the server to a client, it only works when used in a server script.</p> <p>Warning</p> <p>This property can be only called from server scripts.</p>"},{"location":"api/bolt/#fireallclients","title":":FireAllClients","text":"<pre><code>ReliableEvent:FireAllClients(...: T...): ()\n</code></pre> <p>Fires the OnClientEvent event for each connected client. Unlike FireClient, this event does not take a target Player as the first argument, since it fires to all connected players. Since this method is used to communicate from the server to clients, it only works when used in a server script.</p> <p>Warning</p> <p>This property can be only called from server scripts.</p>"},{"location":"api/bolt/#remoteproperty_1","title":"RemoteProperty","text":""},{"location":"api/bolt/#functions_2","title":"Functions","text":""},{"location":"api/bolt/#observe","title":":Observe","text":"<pre><code>RemoteProperty:Observe(callback: (value: T) -&gt; ()): (() -&gt; ())\n</code></pre> <p>Registers a callback function that gets called whenever the property value changes.</p> <p>Registering a callback also means that the first callback it will receive will be the current value of that RemoteProperty.</p> <p>Returns a function that when called disconnects the callback from the RemoteProperty and any further value updates won't be received by this callback function.</p> <p>Warning</p> <p>This property can be only called from client scripts.</p>"},{"location":"api/bolt/#get","title":":Get","text":"<pre><code>RemoteProperty:Get(): T\n</code></pre> <p>Returns the current value of the property.</p>"},{"location":"api/bolt/#getfor","title":":GetFor","text":"<pre><code>RemoteProperty:GetFor(player: Player): T\n</code></pre> <p>Returns the current value of the property for a given player.</p>"},{"location":"api/bolt/#set","title":":Set","text":"<pre><code>RemoteProperty:Set(newValue: T): ()\n</code></pre> <p>Sets the value of the remote property to the newly passed one, if the new value is the same as the old value, the value update will be skipped.</p> <p>When Set is called all of the values set for players using SetFor get cleared and are set to the newly passed value.</p> <p>Warning</p> <p>This function can be only called from server scripts.</p>"},{"location":"api/bolt/#setfor","title":":SetFor","text":"<pre><code>RemoteProperty:SetFor(player: Player, newValue: T): ()\n</code></pre> <p>Sets the value of the remote property for that given player, if the new value is the same as the old value, the value update will be skipped.</p> <p>Only this specific player will receive the value update, an \"overwrite\" gets created for this specific player and any further SetFor calls will compare the new value with this one.</p> <p>Warning</p> <p>This function can be only called from server scripts.</p>"},{"location":"api/bolt/#clearfor","title":":ClearFor","text":"<pre><code>RemoteProperty:ClearFor(player: Player): ()\n</code></pre> <p>Clears the overwriten value that was set by SetFor, if the master value that was set for this remote property is different from the value that was overwritten for the specific player passed in the parameter, they will get a value update.</p> <p>Warning</p> <p>This function can be only called from server scripts.</p>"},{"location":"api/bolt/#remotefunction_1","title":"RemoteFunction","text":""},{"location":"api/bolt/#properties_1","title":"Properties","text":""},{"location":"api/bolt/#onserverinvoke","title":"OnServerInvoke","text":"<pre><code>RemoteFunction.OnServerInvoke: (player: Player, ...: T...): R...\n</code></pre> <p>This callback is called when the RemoteFunction is invoked with InvokeServer. When the bound function returns, the returned values are sent back to the calling client.</p> Example Usage Server.luauClient.luau <pre><code>local remoteFunction = Bolt.RemoteFunction(\"Foo\") :: Bolt.RemoteFunction&lt;(), (string)&gt;\n\nremoteFunction.OnServerInvoke = function(player)\n    return player.DisplayName\nend\n</code></pre> <pre><code>local remoteFunction = Bolt.RemoteFunction(\"Foo\") :: Bolt.RemoteFunction&lt;(), (string)&gt;\n\nprint(remoteFunction:InvokeServer()) --&gt; username\n</code></pre> <p>Warning</p> <p>This property can only be set from server scripts.</p>"},{"location":"api/bolt/#functions_3","title":"Functions","text":""},{"location":"api/bolt/#invokeserver","title":":InvokeServer","text":"<pre><code>RemoteFunction:InvokeServer(...: T...): R...\n</code></pre> <p>Danger</p> <p>This function yields.</p> <p>Invokes the RemoteFunction which in turn calls the OnServerInvoke callback. Since this method is used to communicate from a client to the server, it will only work when used in a client script.</p> <p>Any type of Roblox object such as an Enum, Instance, or others can be passed as a parameter to InvokeServer(), as well as Luau types such as numbers, strings, and booleans.</p> <p>Warning</p> <p>This property can be only called from client scripts.</p>"},{"location":"api/bolt/#bufferreader","title":"BufferReader","text":""},{"location":"api/bolt/#functions_4","title":"Functions","text":""},{"location":"api/bolt/#frombuffer","title":".fromBuffer","text":"<pre><code>BufferReader.fromBuffer(buffer: buffer): BufferReader\n</code></pre>"},{"location":"api/bolt/#frombuffer_1","title":".fromBuffer","text":"<pre><code>BufferReader.fromString(string: string): BufferReader\n</code></pre>"},{"location":"api/bolt/#readb8","title":":ReadB8","text":"<pre><code>BufferReader:ReadB8(): { boolean }\n</code></pre>"},{"location":"api/bolt/#readi8","title":":ReadI8","text":"<pre><code>BufferReader:ReadI8(): number\n</code></pre>"},{"location":"api/bolt/#readi16","title":":ReadI16","text":"<pre><code>BufferReader:ReadI16(): number\n</code></pre>"},{"location":"api/bolt/#readi24","title":":ReadI24","text":"<pre><code>BufferReader:ReadI24(): number\n</code></pre>"},{"location":"api/bolt/#readi32","title":":ReadI32","text":"<pre><code>BufferReader:ReadI32(): number\n</code></pre>"},{"location":"api/bolt/#readu8","title":":ReadU8","text":"<pre><code>BufferReader:ReadU8(): number\n</code></pre>"},{"location":"api/bolt/#readu16","title":":ReadU16","text":"<pre><code>BufferReader:ReadU16(): number\n</code></pre>"},{"location":"api/bolt/#readu24","title":":ReadU24","text":"<pre><code>BufferReader:ReadU24(): number\n</code></pre>"},{"location":"api/bolt/#readu32","title":":ReadU32","text":"<pre><code>BufferReader:ReadU32(): number\n</code></pre>"},{"location":"api/bolt/#readu40","title":":ReadU40","text":"<pre><code>BufferReader:ReadU40(): number\n</code></pre>"},{"location":"api/bolt/#readu56","title":":ReadU56","text":"<pre><code>BufferReader:ReadU56(): number\n</code></pre>"},{"location":"api/bolt/#readf32","title":":ReadF32","text":"<pre><code>BufferReader:ReadF32(): number\n</code></pre>"},{"location":"api/bolt/#readf64","title":":ReadF64","text":"<pre><code>BufferReader:ReadF64(): number\n</code></pre>"},{"location":"api/bolt/#readinstance","title":":ReadInstance","text":"<pre><code>BufferReader:ReadInstance(): Instance\n</code></pre>"},{"location":"api/bolt/#readstring","title":":ReadString","text":"<pre><code>BufferReader:ReadString(count: number?): string\n</code></pre>"},{"location":"api/bolt/#readvector2","title":":ReadVector2","text":"<pre><code>BufferReader:ReadVector2(): Vector2\n</code></pre>"},{"location":"api/bolt/#readvector3","title":":ReadVector3","text":"<pre><code>BufferReader:ReadVector3(): Vector3\n</code></pre>"},{"location":"api/bolt/#readcframe","title":":ReadCFrame","text":"<pre><code>BufferReader:ReadCFrame(): CFrame\n</code></pre>"},{"location":"api/bolt/#readcolor3","title":":ReadColor3","text":"<pre><code>BufferReader:ReadColor3(): Color3\n</code></pre>"},{"location":"api/bolt/#bufferwriter","title":"BufferWriter","text":""},{"location":"api/bolt/#functions_5","title":"Functions","text":""},{"location":"api/bolt/#new","title":".new","text":"<pre><code>BufferWriter.new(size: number): BufferWriter\n</code></pre>"},{"location":"api/bolt/#frombuffer_2","title":".fromBuffer","text":"<pre><code>BufferWriter.fromBuffer(source: buffer): BufferWriter\n</code></pre>"},{"location":"api/bolt/#writeb8","title":":WriteB8","text":"<pre><code>BufferWriter:WriteB8(...boolean): ()\n</code></pre>"},{"location":"api/bolt/#writei8","title":":WriteI8","text":"<pre><code>BufferWriter:WriteI8(value: number): ()\n</code></pre>"},{"location":"api/bolt/#writei16","title":":WriteI16","text":"<pre><code>BufferWriter:WriteI16(value: number): ()\n</code></pre>"},{"location":"api/bolt/#writei24","title":":WriteI24","text":"<pre><code>BufferWriter:WriteI24(value: number): ()\n</code></pre>"},{"location":"api/bolt/#writei32","title":":WriteI32","text":"<pre><code>BufferWriter:WriteI32(value: number): ()\n</code></pre>"},{"location":"api/bolt/#writeu8","title":":WriteU8","text":"<pre><code>BufferWriter:WriteU8(value: number): ()\n</code></pre>"},{"location":"api/bolt/#writeu16","title":":WriteU16","text":"<pre><code>BufferWriter:WriteU16(value: number): ()\n</code></pre>"},{"location":"api/bolt/#writeu24","title":":WriteU24","text":"<pre><code>BufferWriter:WriteU24(value: number): ()\n</code></pre>"},{"location":"api/bolt/#writeu32","title":":WriteU32","text":"<pre><code>BufferWriter:WriteU32(value: number): ()\n</code></pre>"},{"location":"api/bolt/#writeu40","title":":WriteU40","text":"<pre><code>BufferWriter:WriteU40(value: number): ()\n</code></pre>"},{"location":"api/bolt/#writeu56","title":":WriteU56","text":"<pre><code>BufferWriter:WriteU56(value: number): ()\n</code></pre>"},{"location":"api/bolt/#writef32","title":":WriteF32","text":"<pre><code>BufferWriter:WriteF32(value: number): ()\n</code></pre>"},{"location":"api/bolt/#writef64","title":":WriteF64","text":"<pre><code>BufferWriter:WriteF64(value: number): ()\n</code></pre>"},{"location":"api/bolt/#writeinstance","title":":WriteInstance","text":"<pre><code>BufferWriter:WriteInstance(instance: Instance): ()\n</code></pre>"},{"location":"api/bolt/#writestring","title":":WriteString","text":"<pre><code>BufferWriter:WriteString(string: string, count: number?): ()\n</code></pre>"},{"location":"api/bolt/#writevector2","title":":WriteVector2","text":"<pre><code>BufferWriter:WriteVector2(value: Vector2): ()\n</code></pre>"},{"location":"api/bolt/#writevector3","title":":WriteVector3","text":"<pre><code>BufferWriter:WriteVector3(value: Vector3): ()\n</code></pre>"},{"location":"api/bolt/#writecframe","title":":WriteCFrame","text":"<pre><code>BufferWriter:WriteCFrame(value: CFrame): ()\n</code></pre>"},{"location":"api/bolt/#writecolor3","title":":WriteColor3","text":"<pre><code>BufferWriter:WriteColor3(value: Color3): ()\n</code></pre>"},{"location":"api/bolt/#fit","title":":Fit","text":"<pre><code>BufferWriter:Fit(): ()\n</code></pre> <p>Shrinks the internal buffer size to the current internal cursor offset.</p>"},{"location":"api/debug_tools/","title":"API","text":""},{"location":"api/debug_tools/#action","title":"Action","text":""},{"location":"api/debug_tools/#methods","title":"Methods","text":""},{"location":"api/debug_tools/#new","title":".new","text":"<pre><code>DebugTools.Action.new(name: string, description: string?, action: (any...) -&gt; ()), arguments: { Type: \"string\" | \"number\" | \"boolean\" | \"Player\", Name: string?, Default: any?, Options: { any }? })\n</code></pre> <p>Defines a new action, for more information check out Overview.</p> Example Usage <pre><code>DebugTools.Action.new(\"Test Action\", nil, function(player: Player)\n    print(`Player '{player.DisplayName}' executed an action!`)\nend, {\n    {\n        Type = \"Player\",\n        Name = \"Player\",\n    },\n})\n</code></pre>"},{"location":"api/debug_tools/#authorization","title":"Authorization","text":""},{"location":"api/debug_tools/#properties","title":"Properties","text":""},{"location":"api/debug_tools/#playerauthorized","title":"PlayerAuthorized","text":"<pre><code>DebugTools.Authorization.PlayerAuthorized: Signal&lt;Player&gt;\n</code></pre> <p>Fires whenever player gets authorized and is allowed to use DebugTools.</p> <p>This is a server only property.</p>"},{"location":"api/debug_tools/#playerauthorizationlost","title":"PlayerAuthorizationLost","text":"<pre><code>DebugTools.Authorization.PlayerAuthorizationLost: Signal&lt;Player&gt;\n</code></pre> <p>Fires whenever player looses the rights to use DebugTools.</p> <p>This is a server only property.</p>"},{"location":"api/debug_tools/#methods_1","title":"Methods","text":""},{"location":"api/debug_tools/#isplayerauthorizedasync","title":":IsPlayerAuthorizedAsync","text":"<pre><code>DebugTools.Authorization:IsPlayerAuthorizedAsync(player: Player): boolean\n</code></pre> <p>Returns true if player is authorized to use DebugTools, this function can yield if player is in the process of being authorized.</p> <p>Danger</p> <p>This function can yield.</p> <p>This is a server only method.</p>"},{"location":"api/debug_tools/#setauthorizationcallback","title":":SetAuthorizationCallback","text":"<pre><code>DebugTools.Authorization:SetAuthorizationCallback(callback: ((player: Player) -&gt; boolean)?): ()\n</code></pre> <p>Defines a new authorization callback, if callback is missing the default authorization method is used.</p> <p>When changing the authorization callback all of the players in the server will be reauthorized again.</p> <p>This is a server only method.</p>"},{"location":"api/debug_tools/#console","title":"Console","text":""},{"location":"api/debug_tools/#methods_2","title":"Methods","text":""},{"location":"api/debug_tools/#addmessage","title":":AddMessage","text":"<pre><code>DebugTools.Console:AddMessage(text: string, textType: Enum.MessageType, serverSided: boolean): ()\n</code></pre> <p>Adds a message to internal DebugTools console which won't print anything to Robloxes output, the messages will appear only within GetOutputLog and Output widget.</p> <p>This is a client only method.</p>"},{"location":"api/debug_tools/#getoutputlog","title":":GetOutputLog","text":"<pre><code>DebugTools.Console:GetOutputLog(): string\n</code></pre> <p>Returns a string with last 400 messages logged to the internal DebugTools console.</p> <p>This is a client only method.</p>"},{"location":"api/debug_tools/#widget","title":"Widget","text":""},{"location":"api/debug_tools/#methods_3","title":"Methods","text":""},{"location":"api/debug_tools/#new_1","title":".new","text":"<pre><code>DebugTools.Widget.new(widgetName: string, widgetCreateFunction: (parent: ScreenGui) -&gt; () -&gt; ())): ()\n</code></pre> <p>Defines a new widget, for more information check out Overview.</p> <p>This is a client only method.</p>"},{"location":"api/debug_tools/#getall","title":":GetAll","text":"<pre><code>DebugTools.Widget:GetAll(): { [string]: { Mounted: boolean, ScreenGui: ScreenGui? } }\n</code></pre> <p>Returns all of the defined widgets.</p> <p>This is a client only method.</p>"},{"location":"api/debug_tools/#hide","title":":Hide","text":"<pre><code>DebugTools.Widget:Hide(widgetName: string): ()\n</code></pre> <p>Hides a widget.</p> <p>This is a client only method.</p>"},{"location":"api/debug_tools/#show","title":":Show","text":"<pre><code>DebugTools.Widget:Show(widgetName: string): ()\n</code></pre> <p>Shows a widget.</p> <p>This is a client only method.</p>"},{"location":"api/debug_tools/#isvisible","title":":IsVisible","text":"<pre><code>DebugTools.Widget:IsVisible(widgetName: string): boolean\n</code></pre> <p>Returns true if widget is visible.</p> <p>This is a client only method.</p>"},{"location":"api/debug_tools/#switchvisibility","title":":SwitchVisibility","text":"<pre><code>DebugTools.Widget:SwitchVisibility(widgetName: string): ()\n</code></pre> <p>Switches between the current visibility state of a widget, if it's hidden then the widget will be shown and vice versa.</p> <p>This is a client only method.</p>"},{"location":"api/debug_tools/#networking","title":"Networking","text":""},{"location":"api/debug_tools/#methods_4","title":"Methods","text":""},{"location":"api/debug_tools/#sendmessage","title":":SendMessage","text":"<pre><code>DebugTools.Networking:SendMessage(topic: string, ...): ()\n</code></pre> <p>If used from client side, it will send a message to the server.</p> <p>If used from server side, it will send a message to all of the authorized players in the server.</p>"},{"location":"api/debug_tools/#sendmessagetoplayer","title":":SendMessageToPlayer","text":"<pre><code>DebugTools.Networking:SendMessageToPlayer(player: Player, topic: string, ...): ()\n</code></pre> <p>Works similarly to SendMessage but the message will be only sent to just one player.</p> <p>This is a server only method.</p>"},{"location":"api/debug_tools/#subscribetotopic","title":":SubscribeToTopic","text":"<pre><code>DebugTools.Networking:SubscribeToTopic(topic: string, callback: (...any) -&gt; ...any): ()\n</code></pre> <p>Subscribes to a message with a given topic, will trigger a callback with whatever parameters were passed when the message was sent.</p>"},{"location":"api/debug_tools/#tab","title":"Tab","text":""},{"location":"api/debug_tools/#methods_5","title":"Methods","text":""},{"location":"api/debug_tools/#new_2","title":".new","text":"<pre><code>DebugTools.Tab.new(name: string, constructorFunction: (parent: Frame) -&gt; () -&gt; ())\n</code></pre> <p>Defines a new tab, for more information check out Overview.</p> <p>This is a client only method.</p>"},{"location":"api/debug_tools/#imgui","title":"IMGui","text":""},{"location":"api/debug_tools/#methods_6","title":"Methods","text":""},{"location":"api/debug_tools/#applyframestyle","title":".applyFrameStyle","text":"<pre><code>DebugTools.IMGui.applyFrameStyle(instance: Frame | TextButton): ()\n</code></pre> <p>Applies IMGui styling to a given Instance.</p> <p>This is a client only method.</p>"},{"location":"api/debug_tools/#applytextstyle","title":".applyTextStyle","text":"<pre><code>DebugTools.IMGui.applyTextStyle(instance: TextLabel | TextButton): ()\n</code></pre> <p>Applies IMGui styling to a given Instance.</p> <p>This is a client only method.</p>"},{"location":"api/debug_tools/#connect","title":":Connect","text":"<pre><code>DebugTools.IMGui:Connect(parent: GuiBase, tickLoop: () -&gt; ()): () -&gt; ()\n</code></pre> <p>Mounts IMGui under the specified parent instance. The parent and all created instances are fully managed by the IMGui system, so modifying them outside of IMGui\u2019s internal logic is not recommended. All UI logic should be implemented inside the tickLoop function.</p> <p>Returns a destructor function that unmounts the interface from the parent and performs cleanup.</p> <p>This is a client only method.</p>"},{"location":"api/debug_tools/#newwidgetdefinition","title":":NewWidgetDefinition","text":"<pre><code>DebugTools.IMGui:NewWidgetDefinition(identifier: string, definition: WidgetDefinition): ()\n</code></pre> <p>Defines a new IMGui widget that can be accessed by IMGui:identifier.</p> Example Usage <pre><code>IMGui:NewWidgetDefinition(\"Label\", {\n    Construct = function(self: ImguiLabel, parent: GuiObject, text: string)\n        local textInstance: TextLabel = Instance.new(\"TextLabel\")\n        textInstance.Name = `Label ({self.ID})`\n        textInstance.AutomaticSize = Enum.AutomaticSize.XY\n        textInstance.Text = text\n        textInstance.RichText = true\n        textInstance.BackgroundTransparency = 1\n        textInstance.BorderSizePixel = 0\n\n        IMGui.applyTextStyle(textInstance)\n\n        textInstance.Parent = parent\n\n        return textInstance\n    end,\n\n    Update = function(self: ImguiLabel, text: string)\n        self.TopInstance.Text = text\n    end,\n})\n</code></pre> <p>This is a client only method.</p>"},{"location":"api/debug_tools/#gettick","title":":GetTick","text":"<pre><code>DebugTools.IMGui:GetTick(): number\n</code></pre> <p>Returns the current tick of the active tick loop. The value is monotonically increasing.</p> <p>This is a client only method.</p>"},{"location":"api/debug_tools/#getconfig","title":":GetConfig","text":"<pre><code>DebugTools.IMGui:GetConfig(): any\n</code></pre> <p>Returns a table with current IMGui config.</p> <p>This is a client only method.</p>"},{"location":"api/dubit_store/","title":"API","text":""},{"location":"api/dubit_store/#dubitstore","title":"DubitStore","text":"<p>DubitStore is a feature-rich Roblox DataStore wrapper, enabling developers to take advantage over a multitude of advanced features.</p> <p>DubitStore offers quite a lot of features, however, it does not force developers to use these features.. it is up to the developer to choose what features are necessary vs what features to avoid.</p> <p>An brief overview on what DubitStore offers;</p> <ul> <li>Middleware implementation<ul> <li>Middleware enable both developers &amp; DubitStore to write code that mutates the data before or after the data is downloaded or uplodaded.</li> <li>\u26a0\ufe0f Use middleware with caution as it can introduce the ability to corrupt data if miss-used.</li> </ul> </li> <li>Reconciling data<ul> <li>To reconcile data is to help flatten two data's into a single entity, in DubitStore's case it'll be merging remote data with our schema format.</li> <li>To be able to reconcile data, developers must create a \"Schema\", this schema represents what the latets version of that data will look like.<ul> <li>\u2139\ufe0f Schemas will only fill in data which does not exist with an existing data object.</li> </ul> </li> </ul> </li> <li>Session Locking<ul> <li>Session locking isn't enforced in DubitStore, this is because we don't know the application, maybe we do want servers to read &amp; write to data when other servers can.. for instance, a totalizer.</li> </ul> </li> <li>Data Corruption<ul> <li>In the case middleware fail to mutate the state of data, the Data Corrupted signal will be invoked to indicate that data was unable to be processed.</li> </ul> </li> <li>Autosaving data<ul> <li>As DubitStore still doesn't know the use case, we've implemented an abstract way to save player data.. allowing you to bind a function to an autosave key, when this key is fired, your function will be called. It's up to the developer to then save that data.</li> <li>Autosaving intervals can be set, as well as manually called. We do not advise you call an autosave function once that data is dropped.<ul> <li>For instance, an example of this could be invoking the autosave function to save data when the player leaves.. this is because AutoSaving may serve a different purpose to saving data at the end of a session.</li> </ul> </li> </ul> </li> <li>Removing existing data<ul> <li>Since DubitStore isn't player orientated, it does not have the ability to remove player cached data when that player leaves.. this will need to be done through a developer to ensure that when that player joins back, they will not recieve an older version of said data.</li> <li>This is one of the cons for DubitStore, however enables us to use this module in things like Leaderboards and so on.</li> </ul> </li> </ul> <p>Some of the dubit store background handywork;</p> <ul> <li>Type Support<ul> <li>DubitStore has the ability to save objects such as Vector3's, CFrame's and so on.</li> <li>DubitStore achieves this by breaking each object down into a table, implementing components and things of that sort.</li> </ul> </li> <li>BindToClose<ul> <li>DubitStore has full support for when a studio/server is shutting down, it's goal being to save all player data before shutdown.</li> </ul> </li> <li>Cache<ul> <li>DubitStore will only build a cache once a get request is made and there is already no existing cache. The principle behind this is to enable developers to quickly SET &amp; GET data without making multiple datastore requests..</li> <li>This however means, in order to send that data over to the server, you need to \"Push\" that data, Pushing data is the act where we move what we currently have in cache over to the server.<ul> <li>\u26a0\ufe0f If a developer doesn't push any data, no data will be saved as it'll only exist under that specific servers cache.</li> </ul> </li> </ul> </li> <li>Internal Queue &amp; Budgeting<ul> <li>DubitStore relies on both a Queue system and DataStore budgets to regulate how fast requests are made to each endpoint.. this also includes awareness for \"key cooldown\" mentioned in the below document<ul> <li>Devforum Post</li> </ul> </li> </ul> </li> <li>Multi-Threading<ul> <li>DubitStore takes advantage of roblox's parallel thread implementation, allowing DubitStore to work alongside the Roblox VM.</li> </ul> </li> </ul>"},{"location":"api/dubit_store/#properties","title":"Properties","text":""},{"location":"api/dubit_store/#container","title":".Container","text":"<pre><code>DubitStore.Container: Container\n</code></pre>"},{"location":"api/dubit_store/#middleware","title":".Middleware","text":"<pre><code>DubitStore.Middleware: Middleware\n</code></pre>"},{"location":"api/dubit_store/#getrequestfailed","title":".GetRequestFailed","text":"<pre><code>DubitStore.GetRequestFailed: Signal\n</code></pre>"},{"location":"api/dubit_store/#setrequestfailed","title":".SetRequestFailed","text":"<pre><code>DubitStore.SetRequestFailed: Signal\n</code></pre>"},{"location":"api/dubit_store/#orderedgetrequestfailed","title":".OrderedGetRequestFailed","text":"<pre><code>DubitStore.OrderedGetRequestFailed: Signal\n</code></pre>"},{"location":"api/dubit_store/#orderedsetrequestfailed","title":".OrderedSetRequestFailed","text":"<pre><code>DubitStore.OrderedSetRequestFailed: Signal\n</code></pre>"},{"location":"api/dubit_store/#datacorrupted","title":".DataCorrupted","text":"<pre><code>DubitStore.DataCorrupted: Signal\n</code></pre>"},{"location":"api/dubit_store/#pushcompleted","title":".PushCompleted","text":"<pre><code>DubitStore.PushCompleted: Signal\n</code></pre>"},{"location":"api/dubit_store/#functions","title":"Functions","text":""},{"location":"api/dubit_store/#setverbosity","title":":SetVerbosity","text":"<pre><code>DubitStore:SetVerbosity(isVerbose: boolean): ()\n</code></pre> <p>When set to true, all of the debugging logs DubitStore creates will appear, by default this is set to false so only warning+ will appear.</p>"},{"location":"api/dubit_store/#getsizeinbytes","title":":GetSizeInBytes","text":"<pre><code>DubitStore:GetSizeInBytes(datastoreIdentifier: string, datastoreKey: string | Player): number\n</code></pre> <p>This function will return the size of a key in Bytes, this can be used to find how large you can scale your systems.</p> Example Usage <pre><code>DubitStore:GetDataAsync(\"Inventory\", \"player1\"):await()\n\nlocal dataSizeInBytes = DubitStore:GetSizeInBytes(\"Inventory\", \"player1\")\n</code></pre>"},{"location":"api/dubit_store/#isoffline","title":":IsOffline","text":"<pre><code>DubitStore:IsOffline(): boolean\n</code></pre> <p>This function will return a boolean depening on if the library is \"online\", online meaning able to push to a live roblox datastore.</p> <p>Ideally this is useful in scenarios where developers are inside of studio or want to run tests.</p>"},{"location":"api/dubit_store/#setonlinestate","title":":SetOnlineState","text":"<pre><code>DubitStore:SetOnlineState(state: boolean): ()\n</code></pre> <p>This function will override and set the \"online\" state of the library, online meaning able to push to a live roblox datastore.</p>"},{"location":"api/dubit_store/#setdevelopmentchannel","title":":SetDevelopmentChannel","text":"<pre><code>DubitStore:SetDevelopmentChannel(channel: string): ()\n</code></pre> <p>This function will set the development channel for DubitStore, if the development channel is anything other than \"PRODUCTION\" then specific cooldowns won't apply.     - We suggest leaving this unchecked unless you're either developing or debugging an issue.</p>"},{"location":"api/dubit_store/#getdevelopmentchannel","title":":GetDevelopmentChannel","text":"<pre><code>DubitStore:GetDevelopmentChannel(): string\n</code></pre> <p>This function will retrieve the current channel of the library, in the majority of cases, this channel will be \"Production</p>"},{"location":"api/dubit_store/#implementmiddleware","title":":ImplementMiddleware","text":"<pre><code>DubitStore:ImplementMiddleware(middleware: Middleware): Middleware\n</code></pre> <p>This method will help developers implement middleware to recieve &amp; modify data before we set and get that data.</p> Example Usage <pre><code>local middleware = DubitStore.Middleware.new(function(data, middlewareActionType)\n    if middlewareActionType == DubitStore.Middleware.action.Get then\n        -- we can do stuff with 'data' before our library \"gets\" that data.\n\n        ...\n    end\n\n    return data\nend)\n\nDubitStore:ImplementMiddleware(middleware)\n</code></pre>"},{"location":"api/dubit_store/#removemiddleware","title":":RemoveMiddleware","text":"<pre><code>DubitStore:RemoveMiddleware(middleware: Middleware): Middleware\n</code></pre> <p>This method will remove any existing Middleware from DubitStoren</p>"},{"location":"api/dubit_store/#generaterawtable","title":":GenerateRawTable","text":"<pre><code>DubitStore:GenerateRawTable(schemaTable: {[string]: Container}): {[string]: any}\n</code></pre> <p>This function will serialise a schema into a standard Lua table</p> Example Usage <pre><code>local data = DubitStore:GenerateRawTable({\n    ExampleSchemaString = DubitStore.Container.new(\"Super Awesome String!\")\n    ExampleSchemaEntry = DubitStore.Cotainer.new({\n        ExampleSchemaSubEntry = DubitStore.Container.new(\"Super Awesome String 2!\")\n    })\n})\n\nprint(data.ExampleSchemaString) --&gt; Super Awesome String!\n</code></pre>"},{"location":"api/dubit_store/#validatedataschema","title":":ValidateDataSchema","text":"<pre><code>DubitStore:ValidateDataSchema(schemaTable: {[string]: Container}): (boolean, string)\n</code></pre> <p>This function will validate schemas generated by developers.</p> Example Usage <pre><code>local success, errorMessage = DubitStore:ValidateDataSchema({\n    ExampleSchemaString = DubitStore.Container.new(\"Super Awesome String!\")\n    ExampleSchemaEntry = DubitStore.Cotainer.new({\n        ExampleSchemaSubEntry = DubitStore.Container.new(\"Super Awesome String 2!\")\n    })\n})\n</code></pre>"},{"location":"api/dubit_store/#createdataschema","title":":CreateDataSchema","text":"<pre><code>DubitStore:CreateDataSchema(schemaIdentifier: string, schemaTable: {[string]: Container}): ()\n</code></pre> <p>This function will create a data schema, data schemas should be used to validate data as well as update outdated data.</p> Example Usage <pre><code>DubitStore:CreateDataSchema(\"schemaIdentifier\", {\n    ExampleSchemaString = DubitStore.Container.new(\"Super Awesome String!\")\n    ExampleSchemaEntry = DubitStore.Cotainer.new({\n        ExampleSchemaSubEntry = DubitStore.Container.new(\"Super Awesome String 2!\")\n    })\n})\n\n-- \"schemaIdentifier\" is now a direct link to the above schema, we can now use this schema to update/maintain our data!\n</code></pre>"},{"location":"api/dubit_store/#getdataschema","title":":GetDataSchema","text":"<pre><code>DubitStore:GetDataSchema(schemaIdentifier: string): {[string]: Container}\n</code></pre> <p>This function will return the initial schema implemented through CreateDataSchema</p>"},{"location":"api/dubit_store/#schemaexists","title":":SchemaExists","text":"<pre><code>DubitStore:SchemaExists(schemaIdentifier: string): boolean\n</code></pre> <p>This function will return a boolean depending on if the schema identifier is linked to a schema object</p>"},{"location":"api/dubit_store/#reconciledata","title":":ReconcileData","text":"<pre><code>DubitStore:ReconcileData(schemaIdentifier: string): boolean\n</code></pre> <p>This function will fill in the data with the contents of a schema if the data doesn't exist.</p> Example Usage <pre><code>DubitStore:CreateDataSchema(\"schemaIdentifier\", {\n    Exp = DubitStore.Container.new(42),\n    Level = DubitStore.Container.new(2)\n})\n\nlocal schema = DubitStore:ReconcileData({ Level = 1 }, \"schemaIdentifier\")\n\nprint(schema.Level) --&gt; 1\nprint(schema.Exp) --&gt; 42\n</code></pre>"},{"location":"api/dubit_store/#onautosave","title":":OnAutosave","text":"<pre><code>DubitStore:OnAutosave(datastoreIdentifier: string): Signal\n</code></pre> <p>This function returns a signal which'll be invoked each autosave occurance.</p> Example Usage <pre><code>DataStoreModule:OnAutosave(\"Inventory\"):Connect(function()\n\nend)\n</code></pre>"},{"location":"api/dubit_store/#invokeautosave","title":":InvokeAutosave","text":"<pre><code>DubitStore:InvokeAutosave(datastoreIdentifier: string): ()\n</code></pre> <p>This function will invoke the autosave signal</p>"},{"location":"api/dubit_store/#cancelautosave","title":":CancelAutosave","text":"<pre><code>DubitStore:CancelAutosave(datastoreIdentifier: string): ()\n</code></pre> <p>This function will cancel any background workers spawned through SetAutosaveInterval</p>"},{"location":"api/dubit_store/#setautosaveinterval","title":":SetAutosaveInterval","text":"<pre><code>DubitStore:SetAutosaveInterval(datastoreIdentifier: string, interval: number): ()\n</code></pre> <p>This function will spawn a new background worker that'll invoke an autosave signal each interval</p>"},{"location":"api/dubit_store/#clearcache","title":":ClearCache","text":"<pre><code>DubitStore:ClearCache(datastoreIdentifier: string, datastoreKey: string | Player): ()\n</code></pre> <p>This function will remove cached data for a data store key, however if a key is not defined, the datastore cache will be removed instead.</p>"},{"location":"api/dubit_store/#yielduntildataunlocked","title":":YieldUntilDataUnlocked","text":"<pre><code>DubitStore:YieldUntilDataUnlocked(datastoreIdentifier: string, datastoreKey: string | Player, maximumYieldTime?: number?): boolean\n</code></pre> <p>This function will halt the execution of the current thread until either the datastore key can be written to, or the maximum yield time is surpassed</p> <p>If no yield time is passed, then the function will indefinitely wait.</p> Example Usage <pre><code>local unlocked = DubitStore:YieldUntilDataUnlocked(\"datastoreIdentifier\", \"datastoreKey\", 10)\n\nif not unlocked then\n    return\nend\n\nlocal schema = DubitStore:ReconcileData({ Level = 1 }, \"schemaIdentifier\")\n</code></pre>"},{"location":"api/dubit_store/#setdatasessionlocked","title":":SetDataSessionLocked","text":"<pre><code>DubitStore:SetDataSessionLocked(datastoreIdentifier: string, datastoreKey: string | Player, locked: boolean?): ()\n</code></pre> <p>This function will set the 'locked' state of the datastoreKey to a given value, if the data is locked then no other server can write to this key, however when the data is unlocked - servers are able to write to this key.</p> <p>Warning</p> <p>These changes will not take effect until you call :PushAsync to push data, including metadata to the server.</p>"},{"location":"api/dubit_store/#overwritedatasessionlocked","title":":OverwriteDataSessionLocked","text":"<pre><code>DubitStore:OverwriteDataSessionLocked(datastoreIdentifier: string, datastoreKey: string | Player, locked: boolean?): ()\n</code></pre> <p>This function will overwrite the 'locked' state for a given datastoreKey, by overwriting a data session we're risking an older record of that players data never being saved.</p> <p>Warning</p> <p>Once you've overwritten a data session, if the session state is set to true - the previous server will be unable to write to the datastore.</p>"},{"location":"api/dubit_store/#syncdataasync","title":":SyncDataAsync","text":"<pre><code>DubitStore:SyncDataAsync(datastoreIdentifier: string, datastoreKey: string | Player, reconciler: ((data: any, response: any): (...any))?): Promise\n</code></pre> <p>This function will merge the cached data with what the server already has, typically useful in cases where we're not locking player data.</p> <p>In the case we pass no reconciler function, the library will use Sift to merge keys, the cached data taking priority.</p>"},{"location":"api/dubit_store/#getmetadataasync","title":":GetMetaDataAsync","text":"<pre><code>DubitStore:GetMetaDataAsync(datastoreIdentifier: string, datastoreKey: string | Player): Promise&lt;{[string]: any}&gt;\n</code></pre> <p>This function retrieves the MetaData of a key.</p>"},{"location":"api/dubit_store/#setmetadataasync","title":":SetMetaDataAsync","text":"<pre><code>DubitStore:SetMetaDataAsync(datastoreIdentifier: string, datastoreKey: string | Player, value: {[string]: any}): Promise\n</code></pre> <p>This function sets the MetaData of a key.</p>"},{"location":"api/dubit_store/#getdataasync","title":":GetDataAsync","text":"<pre><code>DubitStore:GetDataAsync(datastoreIdentifier: string, datastoreKey: string | Player, version?: string?): Promise&lt; { [string]: any } &gt;\n</code></pre> <p>This function retrieves the Data of a key. You can use the third parameter to fetch an older version of said key.</p> Example Usage <pre><code>DubitStore:CreateDataSchema(\"schema\", {\n    Exp = DubitStore.Container.new(42),\n    Level = DubitStore.Container.new(2)\n})\n\nDubitStore:GetDataAsync(\"datastoreIdentifier\", \"datastoreKey\"):andThen(function(data)\n    data = DubitStore:ReconcileData({ Level = 1 }, \"schema\")\n\n    print(data)\nend)\n</code></pre>"},{"location":"api/dubit_store/#getdataversionsasync","title":":GetDataVersionsAsync","text":"<pre><code>DubitStore:GetDataVersionsAsync(datastoreIdentifier: string, datastoreKey: string | Player, sortDirection?: Enum.SortOrder?, minDate?: number?, maxDate?: number?, pageSize?: number?): Promise&lt;DataStoreVersionPages&gt;\n</code></pre> <p>This function retrieves a list of versions this key currently has.</p>"},{"location":"api/dubit_store/#setdataasync","title":":SetDataAsync","text":"<pre><code>DubitStore:SetDataAsync(datastoreIdentifier: string, datastoreKey: string | Player, value: any): Promise\n</code></pre> <p>This function sets the Data of a key. This method returns a promise in order to do the following:</p> <ul> <li>Remain consistant with it's counterpart, GetAsync</li> <li>Provide a friendly approach to how a developer can handle syntax</li> <li>Scaleable error handling</li> </ul> Example Usage <pre><code>DubitStore:SetDataAsync(\"datastoreIdentifier\", \"datastoreKey\", { abc = 123 })\nDubitStore:PushAsync(\"datastoreIdentifier\", \"datastoreKey\")\n</code></pre> <p>Warning</p> <p>These changes will not take effect until you call PushAsync to push data, including metadata to the server.</p>"},{"location":"api/dubit_store/#updatedataasync","title":":UpdateDataAsync","text":"<pre><code>DubitStore:UpdateDataAsync(datastoreIdentifier: string, datastoreKey: string | Player, callback: (data: any) -&gt; (any)): Promise&lt;string, DataStoreKeyInfo&gt;\n</code></pre> <p>This function will enable developers to both GET and SET data within the same function, avoiding server-server sync issues.</p> Example Usage <pre><code>DubitStore:UpdateDataAsync(\"datastoreIdentifier\", \"datastoreKey\", function(data)\n    return { Coins = data.Coins + 1 }\nend)\n</code></pre> <p>Warning</p> <p>This function will NOT write to cache, you do NOT need to call :PushAsync after making this call.</p>"},{"location":"api/dubit_store/#getorderedkeyasync","title":":GetOrderedKeyAsync","text":"<pre><code>DubitStore:GetOrderedKeyAsync(datastoreIdentifier: string, datastoreKey: string | Player): Promise&lt;number&gt;\n</code></pre> <p>This function retrieves the value for an ordered data store key, this function is useful in the case you want to get a specific players value in an ordered datastore.</p> <p>Warning</p> <p>This function will NOT read cache, it will instead make a query to the datastore backend on each call.</p>"},{"location":"api/dubit_store/#getordereddataasync","title":":GetOrderedDataAsync","text":"<pre><code>DubitStore:GetOrderedDataAsync(datastoreIdentifier: string, ascending: boolean, pageSize: number, minValue?: number?, maxValue?: number?): Promise&lt;DataStorePages&gt;\n</code></pre> <p>This function retrieves ordered datastore pages, enabling the developers to create functionality such as leaderboards.</p> <p>Warning</p> <p>This function will NOT read cache, it will instead make a query to the datastore backend on each call.</p>"},{"location":"api/dubit_store/#setordereddataasync","title":":SetOrderedDataAsync","text":"<pre><code>DubitStore:SetOrderedDataAsync(datastoreIdentifier: string, datastoreKey: string | Player, value: number): Promise&lt;string, DataStoreKeyInfo&gt;\n</code></pre> <p>This function sets the value of 'datastoreKey' to a given input inside of the ordered data store.</p> <p>Warning</p> <p>This function will NOT write to cache, you do NOT need to call PushAsync after making this call.</p>"},{"location":"api/dubit_store/#removeorderedasync","title":":RemoveOrderedAsync","text":"<pre><code>DubitStore:RemoveOrderedAsync(datastoreIdentifier: string, datastoreKey: string | Player): Promise\n</code></pre> <p>This function will remove ordered data that is tied to the 'datastoreKey' under the given 'datastoreIdentifier'</p>"},{"location":"api/dubit_store/#removeasync","title":":RemoveAsync","text":"<pre><code>DubitStore:RemoveAsync(datastoreIdentifier: string, datastoreKey: string | Player): Promise\n</code></pre> <p>This function will remove data that is tied to the 'datastoreKey' under the given 'datastoreIdentifier'</p>"},{"location":"api/dubit_store/#pushasync","title":":PushAsync","text":"<pre><code>DubitStore:PushAsync(datastoreIdentifier: string, datastoreKey: string | Player, userIds?: {number | Player}?): Promise&lt;string, DataStoreKeyInfo&gt;\n</code></pre> <p>This function will push any changes made in the cache to the server, if for some reason the push fails, the promise will reject.</p>"},{"location":"api/dubit_store/#container_1","title":"Container","text":"<p>Containers are objects that contain a value, the object will then provide quality of life functions for manipulating this value.</p>"},{"location":"api/dubit_store/#functions_1","title":"Functions","text":""},{"location":"api/dubit_store/#is","title":".is","text":"<pre><code>Container.is(object?: Container?): boolean\n</code></pre> <p>This function compares the first parameter to the class 'Container'</p>"},{"location":"api/dubit_store/#new","title":".new","text":"<pre><code>Container.new(data: any): Container\n</code></pre> <p>This function constructs a new 'Container' class</p>"},{"location":"api/dubit_store/#tostring","title":":ToString()","text":"<pre><code>Container:ToString(): string\n</code></pre> <p>This function generates a string that shows the following; Container Type, Allocated Data Type, Allocated Data Value.</p>"},{"location":"api/dubit_store/#tovalue","title":":ToValue()","text":"<pre><code>Container:ToValue(): any\n</code></pre> <p>This function returns the allocated Data Value.</p>"},{"location":"api/dubit_store/#todatatype","title":":ToDataType()","text":"<pre><code>Container:ToDataType(): string\n</code></pre> <p>This function returns the type of the allocated Data Value</p>"},{"location":"api/dubit_store/#middleware_1","title":"Middleware","text":"<p>Middleware represents an object that we can create to help transform an input into something else we can use.</p>"},{"location":"api/dubit_store/#properties_1","title":"Properties","text":""},{"location":"api/dubit_store/#action","title":"action","text":"<pre><code>Middleware.action: { [\"Get\"] = \"Get\", [\"Set\" = \"Set\"] }\n</code></pre>"},{"location":"api/dubit_store/#functions_2","title":"Functions","text":""},{"location":"api/dubit_store/#is_1","title":".is","text":"<pre><code>Middleware.is(object?: Middleware?): boolean\n</code></pre> <p>This function compares the first parameter to the 'Middleware' class</p>"},{"location":"api/dubit_store/#new_1","title":".new","text":"<pre><code>Middleware.new(callback: (...any) -&gt; (...any)): Middleware\n</code></pre> <p>This function constructs a new 'Middleware' class</p>"},{"location":"api/dubit_store/#tostring_1","title":":ToString","text":"<pre><code>Middleware:ToString(): string\n</code></pre> <p>This function generates a string that shows the following; Middleware Type, Allocated Data Type, Allocated Data Value.</p>"},{"location":"api/dubit_store/#call","title":":Call","text":"<pre><code>Middleware:Call(...): ...any\n</code></pre>"},{"location":"api/dubit_utils/","title":"API","text":""},{"location":"api/dubit_utils/#accessory","title":"Accessory","text":""},{"location":"api/dubit_utils/#functions","title":"Functions","text":""},{"location":"api/dubit_utils/#isassettypeaccessory","title":".isAssetTypeAccessory","text":"<pre><code>DubitUtils.Accessory.isAssetTypeAccessory(assetType: Enum.AssetType): boolean\n</code></pre> <p>Checks if the given asset type is an accessory.</p> Example Usage <pre><code>print(DubitUtils.Accessory.isAssetTypeAccessory(Enum.AssetType.ShortsAccessory)) --&gt; true\nprint(DubitUtils.Accessory.isAssetTypeAccessory(Enum.AssetType.Animation)) --&gt; false\n</code></pre>"},{"location":"api/dubit_utils/#matchassettypetoaccessorytype","title":".matchAssetTypeToAccessoryType","text":"<pre><code>DubitUtils.Accessory.matchAssetTypeToAccessoryType(assetType: Enum.AssetType): Enum.AccessoryType\n</code></pre> <p>Matches the given asset type to its corresponding accessory type.</p> Example Usage <pre><code>print(DubitUtils.Accessory.matchAssetTypeToAccessoryType(Enum.AssetType.Hat)) --&gt; Enum.AccessoryType.Hat\n</code></pre>"},{"location":"api/dubit_utils/#camera","title":"Camera","text":""},{"location":"api/dubit_utils/#functions_1","title":"Functions","text":""},{"location":"api/dubit_utils/#zoomtoextents","title":".zoomToExtents","text":"<pre><code>DubitUtils.Camera.zoomToExtents(camera: Camera, extentsInstance: BasePart | Model): ()\n</code></pre> <p>Zooms the provided Camera instance to the extents of the provided BasePart or Model instance.</p>"},{"location":"api/dubit_utils/#character","title":"Character","text":""},{"location":"api/dubit_utils/#functions_2","title":"Functions","text":""},{"location":"api/dubit_utils/#clonecharacter","title":".cloneCharacter","text":"<pre><code>DubitUtils.Character.cloneCharacter(character: Model, isAnchored: boolean?): Model?\n</code></pre> <p>Creates a clone of the provided character, without overhead display of display name &amp; health.</p>"},{"location":"api/dubit_utils/#resetcharactertransparency","title":".resetCharacterTransparency","text":"<pre><code>DubitUtils.Character.resetCharacterTransparency(character: Model, tweenInfo: TweenInfo?): ()\n</code></pre> <p>Resets the transparency of all parts within the provided character to the original value, if it was made invisible via Character.setCharacterTransparency.</p> <p>Notice</p> <p>This function must be used in conjunction with setCharacterTransparency, which stores the original transparency values of each part. If the character did not have its transparency modified via that function, this function will fail.</p>"},{"location":"api/dubit_utils/#setcharacterfrozen","title":".setCharacterFrozen","text":"<pre><code>DubitUtils.Character.setCharacterFrozen(character: Model, frozen: boolean?): ()\n</code></pre> <p>Set a provided character to be frozen or unfrozen.</p>"},{"location":"api/dubit_utils/#setcharactertransparency","title":".setCharacterTransparency","text":"<pre><code>DubitUtils.Character.setCharacterTransparency(character: Model, targetTransparency: number, tweenInfo: TweenInfo?): ()\n</code></pre> <p>Sets the transparency of all valid parts within the provided character to the provided value. This will also apply to any valid parts which become a descendant of the character before transparency values are reset.</p> <p>Notice</p> <p>This function is usually intended to be used in conjunction with resetCharacterTransparency, as it will restore the original transparency values of each part, which are stored through this function.</p>"},{"location":"api/dubit_utils/#instance","title":"Instance","text":""},{"location":"api/dubit_utils/#functions_3","title":"Functions","text":""},{"location":"api/dubit_utils/#findancestorwithtag","title":".findAncestorWithTag","text":"<pre><code>DubitUtils.InstanceUtility.findAncestorWithTag(instance: Instance, tag: string): Instance?\n</code></pre> <p>Finds &amp; returns the first ancestor of the given instance with the provided tag, if there is one.</p> <p>Notice</p> <p>This function will ignore the provided instance, and only check its ancestors.</p>"},{"location":"api/dubit_utils/#finddescendantswithtag","title":".findDescendantsWithTag","text":"<pre><code>DubitUtils.InstanceUtility.findDescendantsWithTag(instance: Instance, tag: string): { Instance }\n</code></pre> <p>Danger</p> <p>It is advised to use QueryDescendants instead.</p> <p>Finds &amp; returns a table of descendants of the given instance which have the provided tag.</p> <p>Notice</p> <p>This function will ignore the provided instance, and only check its descendants.</p>"},{"location":"api/dubit_utils/#setdescendanttransparency","title":".setDescendantTransparency","text":"<pre><code>DubitUtils.InstanceUtility.setDescendantTransparency(instance: Instance, transparency: number): ()\n</code></pre> <p>Sets the transparency of a given instance and all of its descendants to a provided value. The transprency to set may be any number, however only values between 0 and 1 are supported (e.g. providing a value above 1 will be equivalent to providing 1).</p> <p>Notice</p> <p>This function will dynamically set either the LocalTransparencyModifier (client, will not replicate) or the Transparency of the instance (server, will replicate), depending on whether the function is called from the client or the server.</p>"},{"location":"api/dubit_utils/#verifyinstance","title":".verifyInstance","text":"<pre><code>DubitUtils.InstanceUtility.verifyInstance(instanceName: string, instanceType: string, instanceParent: Instance?, timeout: number?): Instance?\n</code></pre> <p>Danger</p> <p>This function yields.</p> <p>Ensure that an Instance exists within the given parent Instance, and create it if it does not exist.</p> <p>Danger</p> <p>Developers should ensure that the provided 'instanceType' equates to a valid Instance subclass. This is something that as of current can not be natively checked in Lua/Luau, so will cause an error if it is not valid.</p>"},{"location":"api/dubit_utils/#waitforchildren","title":".waitForChildren","text":"<pre><code>DubitUtils.InstanceUtility.waitForChildren(instance: Instance, query: string, timeout: number?): Instance?\n</code></pre> <p>Danger</p> <p>This function yields.</p> <p>Wait for a series of children to appear in an instance.</p> <p>Warning</p> <p>Will return nil if any of the children do not appear within the provided timeout.</p>"},{"location":"api/dubit_utils/#findinstance","title":".findInstance","text":"<pre><code>DubitUtils.InstanceUtility.findInstance(parent: Instance, path: string): Instance?\n</code></pre> <p>Find instance within a parent, this function removes a need for chaining FindFirstChild calls.</p> <p>The path string must follow the format: instance_name.instance_name.instance_name...</p>"},{"location":"api/dubit_utils/#number","title":"Number","text":""},{"location":"api/dubit_utils/#functions_4","title":"Functions","text":""},{"location":"api/dubit_utils/#abbreviate","title":".abbreviate","text":"<pre><code>DubitUtils.Number.abbreviate(numberToAbbreviate: number, includePlusSymbol: boolean?, decimals: number?): string\n</code></pre> <p>Abbreviates the given number with a large number notation, depending on the nearest power of one thousand lower than it, up to 10 ^ 30 (\"N\").</p> Example Usage <pre><code>print(DubitUtils.Number.abbreviate(372)) --&gt; 372\nprint(DubitUtils.Number.abbreviate(59678)) --&gt; 59K+\nprint(DubitUtils.Number.abbreviate(59678, false)) --&gt; 59K\nprint(DubitUtils.Number.abbreviate(1000000000)) --&gt; 1B\nprint(DubitUtils.Number.abbreviate(4967827362967902)) --&gt; 4Qd+\nprint(DubitUtils.Number.abbreviate(4967827362967902, true, 2)) --&gt; 4.96Qd+\n</code></pre>"},{"location":"api/dubit_utils/#roundtonearest","title":".roundToNearest","text":"<pre><code>DubitUtils.Number.roundToNearest(numberToRound: number, roundTo: number): number\n</code></pre> <p>Rounds a given number to the nearest multiple of the given 'roundTo' number.</p> Example Usage <pre><code>print(DubitUtils.Number.roundToNearest(37, 5)) --&gt; 35\n</code></pre>"},{"location":"api/dubit_utils/#commaseparate","title":".commaSeparate","text":"<pre><code>DubitUtils.Number.commaSeparate(numberToSeparate: number): string\n</code></pre> <p>Separate the given number with commas every three digits to make the number more human-readable.</p> Example Usage <pre><code>DubitUtils.Number.commaSeparate(528) --&gt; 528\nDubitUtils.Number.commaSeparate(59678) --&gt; 59,678\nDubitUtils.Number.commaSeparate(1000000000) --&gt; 1,000,000,000\n</code></pre>"},{"location":"api/dubit_utils/#robloxgroup","title":"RobloxGroup","text":""},{"location":"api/dubit_utils/#functions_5","title":"Functions","text":""},{"location":"api/dubit_utils/#getmemberrank","title":".getMemberRank","text":"<pre><code>DubitUtils.RobloxGroup.getMemberRank(player: Player, groupId: number?, retries: number?): number?\n</code></pre> <p>Get the rank of the given player in the group with the ID provided.</p> <p>Warning</p> <p>If groupId is not provided and the creator ID of the current experience is not that of a group, this function will fail and return nil.</p>"},{"location":"api/dubit_utils/#isplayerabovegrouprank","title":".isPlayerAboveGroupRank","text":"<pre><code>DubitUtils.RobloxGroup.isPlayerAboveGroupRank(player: Player, minimumGroupRank: number, whitelist: {[number]: any}?, retries: number?, creatorIdOverride: number?): boolean\n</code></pre> <p>Check if the specified player is at or above the provided group rank, or otherwise succeeds the permissions of that rank. Returns true if any of the following conditions have been met: - The group rank of the player in the specified group matches or exceeds the minimum group rank - The player is the owner of the game - The player is whitelisted - The game is running in Studio</p> Example Usage <pre><code>DubitUtils.RobloxGroup.isPlayerAboveGroupRank(playerWhoJustJoined, 250, { [aSpecificExternalPlayer.UserId] = true }, 3, 0)\n</code></pre>"},{"location":"api/dubit_utils/#stack","title":"Stack","text":""},{"location":"api/dubit_utils/#properties","title":"Properties","text":""},{"location":"api/dubit_utils/#first","title":"first","text":"<pre><code>DubitUtils.Stack.first: number\n</code></pre>"},{"location":"api/dubit_utils/#last","title":"last","text":"<pre><code>DubitUtils.Stack.last: number\n</code></pre>"},{"location":"api/dubit_utils/#size","title":"size","text":"<pre><code>DubitUtils.Stack.size: number\n</code></pre>"},{"location":"api/dubit_utils/#functions_6","title":"Functions","text":""},{"location":"api/dubit_utils/#new","title":".new","text":"<pre><code>DubitUtils.Stack.new&lt;T&gt;(): Stack&lt;T&gt;\n</code></pre>"},{"location":"api/dubit_utils/#push","title":":push","text":"<pre><code>DubitUtils.Stack:push&lt;T&gt;(value: T): ()\n</code></pre>"},{"location":"api/dubit_utils/#pushfirst","title":":pushFirst","text":"<pre><code>DubitUtils.Stack:pushFirst&lt;T&gt;(value: T): ()\n</code></pre>"},{"location":"api/dubit_utils/#pushlast","title":":pushLast","text":"<pre><code>DubitUtils.Stack:pushFirst&lt;T&gt;(value: T): ()\n</code></pre>"},{"location":"api/dubit_utils/#pop","title":":pop","text":"<pre><code>DubitUtils.Stack:pop&lt;T&gt;(): T?\n</code></pre>"},{"location":"api/dubit_utils/#popfirst","title":":popFirst","text":"<pre><code>DubitUtils.Stack:popFirst&lt;T&gt;(): T?\n</code></pre>"},{"location":"api/dubit_utils/#poplast","title":":popLast","text":"<pre><code>DubitUtils.Stack:popLast&lt;T&gt;(): T?\n</code></pre>"},{"location":"api/dubit_utils/#peek","title":":peek","text":"<pre><code>DubitUtils.Stack:peek&lt;T&gt;(): T?\n</code></pre>"},{"location":"api/dubit_utils/#peekfirst","title":":peekFirst","text":"<pre><code>DubitUtils.Stack:peekFirst&lt;T&gt;(): T?\n</code></pre>"},{"location":"api/dubit_utils/#peeklast","title":":peekLast","text":"<pre><code>DubitUtils.Stack:peekLast&lt;T&gt;(): T?\n</code></pre>"},{"location":"api/dubit_utils/#table","title":"Table","text":""},{"location":"api/dubit_utils/#functions_7","title":"Functions","text":""},{"location":"api/dubit_utils/#construct","title":".construct","text":"<pre><code>DubitUtils.Table.construct&lt;T&gt;(constructingFunction: () -&gt; T): T\n</code></pre> <p>Construct a table from a given function.</p> <p>The only reason it exists so the code looks \"cleaner\" (very subjective).</p> Example Usage <pre><code>local COLOR_PALETTE = DubitUtils.Table.construct(function()\n    local hexColors = { \"#FF0000\", \"#00FF00\", \"#0000FF\" }\n    local colors = {}\n    for i, hex in hexColors do\n        colors[i] = Color3.fromHex(hex)\n    end\n    return colors\nend)\n</code></pre>"},{"location":"api/dubit_utils/#compare","title":".compare","text":"<pre><code>DubitUtils.Table.compare(source: {[any]: any}, other: {[any]: any}): boolean\n</code></pre> <p>This function roughly (It won't traverse other tables) compares two tables, both arrays and dictionaries are supported.</p> <p>Cyclical References not supported.</p> Example Usage <pre><code>local tbl_one = { test = true }\nlocal tbl_two = { test = true, hello = \"world\" }\nprint(DubitUtils.Table.compare(tbl)) --&gt; false\n\nlocal tbl_one = { test = true }\nlocal tbl_two = { test = true }\nprint(DubitUtils.Table.compare(tbl)) --&gt; true\n\n\nlocal tbl_one = { test = true, nested = { foo = \"bar\" } }\nlocal tbl_two = { test = true, nested = { foo = \"bar\" } }\nprint(DubitUtils.Table.compare(tbl)) --&gt; false, the table entries are roughly compared, both values of nested fields point to different tables\n</code></pre>"},{"location":"api/dubit_utils/#comparedeep","title":".compareDeep","text":"<pre><code>DubitUtils.Table.compareDeep&lt;A, B&gt;(source: A, other: B): boolean\n</code></pre> <p>This function deeply compares two tables, both arrays and dictionaries are supported.</p> <p>Cyclical References not supported.</p> Example Usage <pre><code>local tbl_one = { test = true }\nlocal tbl_two = { test = true, hello = \"world\" }\nprint(DubitUtils.Table.compareDeep(tbl)) --&gt; false\n\nlocal tbl_one = { test = true }\nlocal tbl_two = { test = true }\nprint(DubitUtils.Table.compareDeep(tbl)) --&gt; true\n\n\nlocal tbl_one = { test = true, nested = { foo = \"bar\" } }\nlocal tbl_two = { test = true, nested = { foo = \"bar\" } }\nprint(DubitUtils.Table.compareDeep(tbl)) --&gt; true\n</code></pre>"},{"location":"api/dubit_utils/#deepclone","title":".deepClone","text":"<pre><code>DubitUtils.Table.deepClone&lt;T&gt;(tbl: T): T\n</code></pre> <p>This function creates a deep copy of given table.</p> <p>Cyclical References not supported.</p> Example Usage <pre><code>local tbl = { test = true }\nlocal tblClone = DubitUtils.Table.deepClone(tbl)\ntblClone.test = false -- will only modify the table contents of the tblClone\nprint(tbl.test, tblClone.test) --&gt; true, false\n</code></pre>"},{"location":"api/dubit_utils/#deepfreeze","title":".deepFreeze","text":"<pre><code>DubitUtils.Table.deepFreeze&lt;T&gt;(tbl: T): T\n</code></pre> <p>This function deep freezes the table making it read only.</p> <p>Cyclical References not supported.</p> Example Usage <pre><code>local tbl = { test = true }\nDubitUtils.Table.deepFreeze(tbl)\ntbl.test = false --&gt; attempt to modify a readonly table\n</code></pre>"},{"location":"api/dubit_utils/#merge","title":".merge","text":"<pre><code>DubitUtils.Table.merge(source: {[any]: any}, other: {[any]: any})\n</code></pre> <p>Merges two given tables together, if source table has a property that other table has - it will be overwritten with the value of other table.</p> <p>Cyclical References not supported.</p> Example Usage <pre><code>local tbl = { test = true, foo = 8 }\nlocal tblOther = { test = false, bar = 16 }\nprint(DubitUtils.Table.merge(tbl, tblOther)) --&gt; { test = false, foo = 8, bar = 16 }\n</code></pre>"},{"location":"api/dubit_utils/#getrandomdictionaryentry","title":".getRandomDictionaryEntry","text":"<pre><code>DubitUtils.Table.merge(source: {[string]: any}, other: {[string]: any})\n</code></pre> <p>Gets a random entry (key-value pair) from a given dictionary.</p>"},{"location":"api/dubit_utils/#stringify","title":".stringify","text":"<pre><code>DubitUtils.Table.stringify(tableBase: {[any]: any}), options: { spaces: number?, usesemicolon: boolean?, depth: number? }): string\n</code></pre> <p>'Stringifies' a table, recursively converting it to a string representation of its contents.</p> <p>Options: spaces - The number of spaces to use for indentation usesemicolon - Whether to use a semicolon instead of a comma for separating table entries depth - The depth of the table in the recursion to stringify up to</p> Example Usage <pre><code>local tbl = { test = true, foo = 8 }\nlocal stringifiedTable = DubitUtils.Table.stringify(tbl)\nprint(stringifiedTable)\n--&gt; {\n--&gt;     [\"test\"] = true;\n--&gt;     [\"foo\"] = 8\n--&gt; } \n</code></pre>"},{"location":"api/dubit_utils/#time","title":"Time","text":""},{"location":"api/dubit_utils/#functions_8","title":"Functions","text":""},{"location":"api/dubit_utils/#formattocountdowntimer","title":".formatToCountdownTimer","text":"<pre><code>DubitUtils.Time.formatToCountdownTimer(seconds: number): string\n</code></pre> <p>Formats seconds to countdown timer format (hr:mm:ss).</p> Example Usage <pre><code>print(DubitUtils.Time.formatToCountdownTimer(59)) --&gt; 00:00:59\nprint(DubitUtils.Time.formatToCountdownTimer(127)) --&gt; 00:02:07\nprint(DubitUtils.Time.formatToCountdownTimer(86399)) --&gt; 23:59:59\n</code></pre>"},{"location":"api/dubit_utils/#formattoracetimer","title":".formatToRaceTimer","text":"<pre><code>DubitUtils.Time.formatToRaceTimer(seconds: number): string\n</code></pre> <p>Formats seconds to race like timer format (mm:ss:msms). This differs from Time.formatToRaceTimer as this one gives a lot more precise time back. (Useful for racing games)</p> Example Usage <pre><code>print(DubitUtils.Time.formatToRaceTimer(59.99)) --&gt; 00:59.990\nprint(DubitUtils.Time.formatToRaceTimer(127.138)) --&gt; 02:07.138\nprint(DubitUtils.Time.formatToRaceTimer(16.552)) --&gt; 00:16.552\nprint(DubitUtils.Time.formatToRaceTimer(6)) --&gt; 00:06.000\n</code></pre>"},{"location":"api/dubit_utils/#formattoracetimerdetailed","title":".formatToRaceTimerDetailed","text":"<pre><code>DubitUtils.Time.formatToRaceTimerDetailed(seconds: number): string\n</code></pre> <p>Formats seconds to race like timer format (mm:ss:msms). This differs from Time.formatToRaceTimer as this one gives a lot more precise time back. (Useful for racing games)</p> Example Usage <pre><code>print(DubitUtils.Time.formatToRaceTimer(59.99)) --&gt; 00:59.9900\nprint(DubitUtils.Time.formatToRaceTimer(127.138)) --&gt; 02:07.1380\nprint(DubitUtils.Time.formatToRaceTimer(16.552)) --&gt; 00:16.5520\nprint(DubitUtils.Time.formatToRaceTimer(6)) --&gt; 00:06.0000\n</code></pre>"},{"location":"api/dubit_utils/#formatsecondstominutesandseconds","title":".formatSecondsToMinutesAndSeconds","text":"<pre><code>DubitUtils.Time.formatSecondsToMinutesAndSeconds(seconds: number, useNotations: boolean?): string\n</code></pre> <p>Formats the given time in seconds to minutes and seconds, in the format of minutes:seconds or [minutes]m[seconds]s</p> Example Usage <pre><code>print(DubitUtils.Time.formatSecondsToMinutesAndSeconds(1235)) --&gt; 20:35\nprint(DubitUtils.Time.formatSecondsToMinutesAndSeconds(12)) --&gt; 00:12\nprint(DubitUtils.Time.formatSecondsToMinutesAndSeconds(1235, true)) --&gt; 20m35s\nprint(DubitUtils.Time.formatSecondsToMinutesAndSeconds(12, true)) --&gt; 12s\n</code></pre>"},{"location":"api/dubit_utils/#getformattedtimeofday","title":".getFormattedTimeOfDay","text":"<pre><code>DubitUtils.Time.getFormattedTimeOfDay(unixTimestamp: number?): string\n</code></pre> <p>Formats the given time of day provided as a timestamp in the format of hours:minutes:seconds, formatting the current time of day if no timestamp is provided.</p> Example Usage <pre><code>print(DubitUtils.Time.getFormattedTimeOfDay()) -- will print current time in the 00:00:00 format\nprint(DubitUtils.Time.getFormattedTimeOfDay(1702723900)) --&gt; 10:51:40\n</code></pre>"},{"location":"api/dubit_utils/#vector","title":"Vector","text":""},{"location":"api/dubit_utils/#functions_9","title":"Functions","text":""},{"location":"api/dubit_utils/#findnearestgroundaroundpoint","title":".findNearestGroundAroundPoint","text":"<pre><code>DubitUtils.Vector.findNearestGroundAroundPoint(origin: Vector3, radius: number, params: RaycastParams?): Vector3\n</code></pre> <p>Returns the nearest ground point within a sphere radius around origin, if it doesn't find any ground point it returns the origin.</p>"},{"location":"api/dubit_utils/#findrandomgroundaroundpoint","title":".findRandomGroundAroundPoint","text":"<pre><code>DubitUtils.Vector.findRandomGroundAroundPoint(origin: Vector3, radius: number, params: RaycastParams?): Vector3\n</code></pre> <p>Returns a random point on the ground within a sphere radius around origin, if it doesn't find any ground point it returns the origin.</p>"},{"location":"api/dubit_utils/#getrandompointinpart","title":".getRandomPointInPart","text":"<pre><code>DubitUtils.Vector.getRandomPointInPart(part: BasePart, randomiseYPosition: boolean?): Vector3\n</code></pre> <p>Gets and returns a random position within a given part, with the option to only randomise along the X &amp; Z axes and optionally Y axis.</p>"},{"location":"api/dubit_utils/#quadraticbezier","title":".quadraticBezier","text":"<pre><code>DubitUtils.Vector.quadraticBezier(time: number, p0, p1, p2)\n</code></pre>"},{"location":"api/dubit_utils/#fzy","title":"fzy","text":""},{"location":"api/dubit_utils/#functions_10","title":"Functions","text":""},{"location":"api/dubit_utils/#filter","title":".filter","text":"<pre><code>DubitUtils.fzy.filter(needle: string, haystack: string, caseSensitive: boolean?): { {number, { number }, number } }\n</code></pre>"},{"location":"api/dubit_utils/#hasmatch","title":".hasMatch","text":"<pre><code>DubitUtils.fzy.hasMatch(needle: string, haystack: string, caseSensitive: boolean?): boolean\n</code></pre> <p>Check if needle is a subsequence of the haystack.</p> <p>Usually called before score or positions.</p>"},{"location":"api/dubit_utils/#positions","title":".positions","text":"<pre><code>DubitUtils.fzy.positions(needle: string, haystack: string, caseSensitive: boolean?): { [number]: number }\n</code></pre> <p>Compute the locations where fzy matches a string.</p> <p>Determine where each character of the needle is matched to the haystack in the optimal match.</p>"},{"location":"api/dubit_utils/#score","title":".score","text":"<pre><code>DubitUtils.fzy.score(needle: string, haystack: string, caseSensitive: boolean?): number\n</code></pre> <p>Compute a matching score.</p>"},{"location":"api/engagements/","title":"API","text":"<p>The Roblox Engagement tool is a package that enables developers to easily query and handle events, objects, interfaces engagements from within a Roblox experience.</p> <p>IAB (Interactive Advertising Bureau) provides a generalized set of rules/guidelines that we can follow in order to better evaluate if a player has engaged with an event or not.</p> <p>Sources in order for us to be IAB (Interactive Advertising Bureau) compliance are as follows: https://www.iab.com/wp-content/uploads/2015/06/dig_vid_imp_meas_guidelines_finalv2.pdf</p>"},{"location":"api/engagements/#functions","title":"Functions","text":""},{"location":"api/engagements/#trackgui","title":"TrackGui","text":"<pre><code>Engagements.TrackGui(gui: ScreenGui, identifier: string): ()\n</code></pre> <p>Tracks when a GUI is viewed or interacted with by:</p> <ul> <li>Setting a unique identifier as an attribute on the GUI.</li> <li>Tagging the GUI so it can be recognized later.</li> <li>This allows the client side system to detect and respond to GUI visibility and interactions.</li> </ul> <p>This is a client only method.</p>"},{"location":"api/engagements/#trackvideo","title":"TrackVideo","text":"<pre><code>Engagements.TrackVideo(video: VideoFrame, identifier: string?): ()\n</code></pre> <p>Tracks when a video is watched by:</p> <ul> <li>Setting a unique identifier as an attribute on the video.</li> <li>Tagging the video so it can be recognized later.</li> <li>This allows the client side system to detect and respond to video playback. The WatchedVideo signal will be triggered when the video ends or loops.</li> </ul> <p>This is a server only method.</p>"},{"location":"api/engagements/#trackzone","title":"TrackZone","text":"<pre><code>Engagements.TrackZone(zone: Model, identifier: string?): ()\n</code></pre> <p>Tracks when a player enters or leaves a zone by:</p> <ul> <li>Setting a unique identifier as an attribute on the zone.</li> <li>Tagging the zone so it can be recognized later.</li> <li>This allows the client side system to detect and respond to player movement in and out of designated zones. The ZoneEntered and ZoneLeft signals will be triggered when relevant.</li> </ul> <p>This is a server only method.</p>"},{"location":"api/engagements/#trackobject","title":"TrackObject","text":"<pre><code>Engagements.TrackObject(object: Model, identifier: string?): ()\n</code></pre> <p>Tracks when an object enters the players viewport:</p> <ul> <li>Setting a unique identifier as an attribute on the zone.</li> <li>Tagging the zone so it can be recognized later.</li> </ul> <p>This allows the client side system to detect and respond to objects appearing in the players viewport. This function will invoke the following signals:</p> <ul> <li>InScreenshot</li> </ul> <p>This is a server only method.</p>"},{"location":"api/engagements/#initialize","title":"Initialize","text":"<pre><code>Engagements.Initialize(): ()\n</code></pre> <p>Initializes the Engagements package by setting up necessary event listeners and tracking systems.</p> <p>How It Works:</p> <ul> <li>Ensures initialization only happens once.</li> <li>Retrieves the package's remote event for communication.</li> <li>If running on the server, it listens for <code>ZoneEntered</code> and <code>ZoneLeft</code> events    from clients and fires corresponding signals.</li> <li>If running on the client, it:<ul> <li>Tracks engagement zones by binding to tagged objects.</li> <li>Runs validation checks each frame (<code>Heartbeat</code>).</li> <li>Updates character overlap parameters when the player\u2019s character is added or removed.</li> </ul> </li> </ul> <p>Warning</p> <p>The Engagements package initializes itself automatically. Developers requiring this module do not need to call this function.</p>"},{"location":"api/event_tracker/","title":"API","text":"<p>The 'EventTracker' tool will allow developers to easily integrate \"live\" events into Roblox experiences.</p> <p>EventTracker is based around an OOP paradigm, instantiating events and then using that generated object to interact with the Live event. Here are a few features that this module offers:</p> <ul> <li>Event Objects<ul> <li>Event Objects allow developers to easily generate events that'll occur at a specific point in the future.</li> </ul> </li> <li>UTC Time-Based<ul> <li>UTC (Coordinated Universal Time) is the primary time standard that is used to regulate things like clocks, we've inherited this behaviour into the Event Tracker as well!</li> </ul> </li> </ul>"},{"location":"api/event_tracker/#eventtracker","title":"EventTracker","text":""},{"location":"api/event_tracker/#types","title":"Types","text":""},{"location":"api/event_tracker/#timezone","title":"TimeZone","text":"<pre><code>type TimeZone = {\n    CentralAfricaTime: number,\n    EastAfricaTime: number,\n    WestAfricaTime: number,\n    SouthAfricaStandardTime: number,\n    MoroccoStandardTime: number,\n    IndiaStandardTime: number,\n    ChinaStandardTime: number,\n    JapanStandardTime: number,\n    KoreaStandardTime: number,\n    CentralEuropeanTime: number,\n    EasternEuropeanTime: number,\n    BritishSummerTime: number,\n    GreenwichMeanTime: number,\n    EasternStandardTime: number,\n    CentralStandardTime: number,\n    MountainStandardTime: number,\n    PacificStandardTime: number,\n    AlaskaStandardTime: number,\n    HawaiiAleutianStandardTime: number,\n    AustralianEasternStandardTime: number,\n    AustralianCentralStandardTime: number,\n    AustralianWesternStandardTime: number,\n    LordHoweStandardTime: number\n}\n</code></pre>"},{"location":"api/event_tracker/#properties","title":"Properties","text":""},{"location":"api/event_tracker/#event","title":"Event","text":"<pre><code>EventTracker.Event: Event\n</code></pre>"},{"location":"api/event_tracker/#eventactivated","title":"EventActivated","text":"<pre><code>EventTracker.EventActivated: Signal\n</code></pre>"},{"location":"api/event_tracker/#eventdeactivated","title":"EventDeactivated","text":"<pre><code>EventTracker.EventDeactivated: Signal\n</code></pre>"},{"location":"api/event_tracker/#timer","title":"Timer","text":"<pre><code>EventTracker.Timer: Timer\n</code></pre>"},{"location":"api/event_tracker/#timersupdated","title":"TimersUpdated","text":"<pre><code>EventTracker.TimersUpdated: Signal\n</code></pre>"},{"location":"api/event_tracker/#timezone_1","title":"TimeZone","text":"<pre><code>EventTracker.TimeZone: TimeZone\n</code></pre>"},{"location":"api/event_tracker/#utc","title":"UTC","text":"<pre><code>EventTracker.UTC: UTC\n</code></pre>"},{"location":"api/event_tracker/#functions","title":"Functions","text":""},{"location":"api/event_tracker/#getactiveevents","title":":GetActiveEvents","text":"<pre><code>EventTracker:GetActiveEvents(): { Event }\n</code></pre> <p>This function will retrieve an array of active events happening at the moment</p>"},{"location":"api/event_tracker/#getevent","title":":GetEvent","text":"<pre><code>EventTracker:GetEvent(eventLabel: string): Event\n</code></pre> <p>This function will retrieve an event from it's label.</p>"},{"location":"api/event_tracker/#getnextevent","title":":GetNextEvent","text":"<pre><code>EventTracker:GetNextEvent(): Event?\n</code></pre> <p>This function will retrieve the next tracked event</p>"},{"location":"api/event_tracker/#getupcomingevents","title":":GetUpcomingEvents","text":"<pre><code>EventTracker:GetUpcomingEvents(): { Event }\n</code></pre> <p>This function will retrieve an sorted array of upcoming events, the array is sorted so closest events are first.</p>"},{"location":"api/event_tracker/#settimerfrequency","title":":SetTimerFrequency","text":"<pre><code>EventTracker:SetTimerFrequency(value: number): Event\n</code></pre> Example Usage <pre><code>EventTracker:SetTimerFrequency(0.5)\n\nlocal t = tick()\nEventTracker.TimersUpdated:Wait()\nprint(tick() - t) -- &gt; around 0.5\n</code></pre>"},{"location":"api/event_tracker/#start","title":":Start","text":"<pre><code>EventTracker:Start(): ()\n</code></pre> <p>This function will start the background process for updating all event timers. It is important this function is called during runtime.</p> <p>Warning</p> <p>This function is required to be called during your games init process, if this function is not called then events will not be started/ended</p>"},{"location":"api/event_tracker/#event_1","title":"Event","text":"<p>The 'Event' class is the primary class developers will interact with, it's job is to manipulate the logic for a live event.</p>"},{"location":"api/event_tracker/#properties_1","title":"Properties","text":""},{"location":"api/event_tracker/#activated","title":"Activated","text":"<pre><code>Event.Activated: Signal\n</code></pre>"},{"location":"api/event_tracker/#deactivated","title":"Deactivated","text":"<pre><code>Event.Deactivated: Signal\n</code></pre>"},{"location":"api/event_tracker/#endtimer","title":"EndTimer","text":"<pre><code>Event.EndTimer: Timer?\n</code></pre>"},{"location":"api/event_tracker/#starttimer","title":"StartTimer","text":"<pre><code>Event.StartTimer: Timer?\n</code></pre>"},{"location":"api/event_tracker/#utcendtime","title":"UTCEndTime","text":"<pre><code>Event.UTCEndTime: UTC?\n</code></pre>"},{"location":"api/event_tracker/#utcstarttime","title":"UTCStartTime","text":"<pre><code>Event.UTCStartTime: UTC?\n</code></pre>"},{"location":"api/event_tracker/#label","title":"Label","text":"<pre><code>Event.Label: string\n</code></pre>"},{"location":"api/event_tracker/#functions_1","title":"Functions","text":""},{"location":"api/event_tracker/#new","title":".new","text":"<pre><code>Event.new(name: string, data: { UTCStartTime: UTC?, UTCEndTime: UTC? }): Event\n</code></pre> <p>This function constructs a new 'Event' class</p>"},{"location":"api/event_tracker/#is","title":".is","text":"<pre><code>Event.is(object?: Event?): boolean\n</code></pre> <p>This function compares the first parameter to the 'Event' class</p>"},{"location":"api/event_tracker/#destroy","title":":Destroy","text":"<pre><code>Event:Destroy(): ()\n</code></pre> <p>This function will cleanup any connections the Event has made in it's lifetime.</p>"},{"location":"api/event_tracker/#disabletimerupdates","title":":DisableTimerUpdates","text":"<pre><code>Event:DisableTimerUpdates(): ()\n</code></pre> <p>This function will disable the logic for updating timers, developers may want to do this in the case they want to manually start or stop an event without timers taking precedence over event state.</p>"},{"location":"api/event_tracker/#enabletimerupdates","title":":EnableTimerUpdates","text":"<pre><code>Event:EnableTimerUpdates(): ()\n</code></pre> <p>This function will enable the logic for updating timers.</p>"},{"location":"api/event_tracker/#getstate","title":":GetState","text":"<pre><code>Event:GetState(): boolean\n</code></pre> <p>This function will return the state of an event, if this state is 'true' then the event is active.</p>"},{"location":"api/event_tracker/#gettimeuntilend","title":":GetTimeUntilEnd","text":"<pre><code>Event:GetTimeUntilEnd(): number\n</code></pre> <p>This function will return the amount of seconds before the end of an event.</p>"},{"location":"api/event_tracker/#gettimeuntilstart","title":":GetTimeUntilStart","text":"<pre><code>Event:GetTimeUntilStart(): number\n</code></pre> <p>This function will return the amount of seconds before the start of an event.</p>"},{"location":"api/event_tracker/#istracked","title":":IsTracked","text":"<pre><code>Event:IsTracked(): boolean\n</code></pre> <p>This function will return a boolean depending if this event has time constraints.</p>"},{"location":"api/event_tracker/#onactivated","title":":OnActivated","text":"<pre><code>Event:OnActivated(): ()\n</code></pre> <p>This lifecycle function is called when the event is first activated.</p> <p>Warning</p> <p>Aim to perform synchronous operations inside of lifecycle methods</p>"},{"location":"api/event_tracker/#ondeactivated","title":":OnDeactivated","text":"<pre><code>Event:OnDeactivated(): ()\n</code></pre> <p>This lifecycle function is called when the event has expired.</p> <p>Warning</p> <p>Aim to perform synchronous operations inside of lifecycle methods</p>"},{"location":"api/event_tracker/#setstate","title":":SetState","text":"<pre><code>Event:SetState(state: boolean): ()\n</code></pre> <p>This function will set the state of an event, this is typically handled internally but is exposed for developer debugging.</p>"},{"location":"api/event_tracker/#tostring","title":":ToString","text":"<pre><code>Event:ToString(): string\n</code></pre> <p>This function generates a string that shows the following; Event Type, Event Label.</p>"},{"location":"api/event_tracker/#updatetimers","title":":UpdateTimers","text":"<pre><code>Event:UpdateTimers(): ()\n</code></pre> <p>This function will update the Timers generated by this event.</p>"},{"location":"api/event_tracker/#timer_1","title":"Timer","text":"<p>The 'Timer' class is an internal class that helps to track the time left before the start or end of an event occurs.</p>"},{"location":"api/event_tracker/#functions_2","title":"Functions","text":""},{"location":"api/event_tracker/#new_1","title":".new","text":"<pre><code>Timer.new(expirationUTC: UTC): Timer\n</code></pre> <p>This function constructs a new 'Timer' class.</p>"},{"location":"api/event_tracker/#is_1","title":".is","text":"<pre><code>Timer.is(object: Timer?): boolean\n</code></pre> <p>This function compares the first parameter to the 'Timer' class.</p>"},{"location":"api/event_tracker/#getdeltatime","title":":GetDeltaTime","text":"<pre><code>Timer:GetDeltaTime(): number\n</code></pre> <p>This function will return the time required to hit the UTC target.</p>"},{"location":"api/event_tracker/#isactive","title":":IsActive","text":"<pre><code>Timer:IsActive(): boolean\n</code></pre> <p>This function will return the current state of the Timer, weather or ot it is active.</p>"},{"location":"api/event_tracker/#isexpired","title":":IsExpired","text":"<pre><code>Timer:IsExpired(): boolean\n</code></pre> <p>This function will let developers know if we've passed the UTC target, then causing the Timer to expire.</p>"},{"location":"api/event_tracker/#tostring_1","title":":ToString","text":"<pre><code>Timer:ToString(): string\n</code></pre> <p>This function generates a string that shows the following; Timer Type, UTC</p>"},{"location":"api/event_tracker/#utc_1","title":"UTC","text":""},{"location":"api/event_tracker/#functions_3","title":"Functions","text":""},{"location":"api/event_tracker/#from","title":".from","text":"<pre><code>UTC.from(epoch: number): UTC\n</code></pre> <p>This function constructs a new 'UTC' class from an unix timestamp.</p>"},{"location":"api/event_tracker/#is_2","title":".is","text":"<pre><code>UTC.is(object?: UTC?): boolean\n</code></pre> <p>This function compares the first parameter to the 'Event' class.</p>"},{"location":"api/event_tracker/#new_2","title":".new","text":"<pre><code>UTC.new(dateTable: { Year: number, Month: number, Day: number, Hour: number, Minute: number, Second: number }): UTC\n</code></pre> <p>This function constructs a new 'UTC' class.</p>"},{"location":"api/event_tracker/#now","title":".now","text":"<pre><code>UTC.now(): UTC\n</code></pre> <p>This function returns the current UTC time.</p>"},{"location":"api/event_tracker/#getepochtime","title":":GetEpochTime","text":"<pre><code>UTC:GetEpochTime(): number\n</code></pre> <p>This function will return the epoch time with an UTC offset applied.</p>"},{"location":"api/event_tracker/#setutcoffset","title":":SetUTCOffset","text":"<pre><code>UTC:SetUTCOffset(offset: number): UTC\n</code></pre> <p>This function will apply a UTC offset to the epoch.</p>"},{"location":"api/event_tracker/#tostring_2","title":":ToString","text":"<pre><code>UTC:ToString(): string\n</code></pre> <p>This function generates a string that shows the following; UTC Type, Epoch</p>"},{"location":"api/sequence_animator/","title":"API","text":""},{"location":"api/sequence_animator/#sequenceanimator","title":"SequenceAnimator","text":""},{"location":"api/sequence_animator/#functions","title":"Functions","text":""},{"location":"api/sequence_animator/#new","title":".new","text":"<pre><code>SequenceAnimator.new(model: Model): SequenceAnimatorInstance\n</code></pre> <p>Creates a new SequenceAnimatorInstance allowing for playing KeyframeSequences on a given Model.</p>"},{"location":"api/sequence_animator/#sequenceanimatorinstance","title":"SequenceAnimatorInstance","text":""},{"location":"api/sequence_animator/#functions_1","title":"Functions","text":""},{"location":"api/sequence_animator/#loadsequence","title":":LoadSequence","text":"<pre><code>SequenceAnimatorInstance:LoadSequence(sequence: KeyframeSequence): SequenceTrack\n</code></pre> <p>This function loads the given KeyframeSequence onto this SequenceAnimatorInstance, returning a playable SequenceTrack.</p>"},{"location":"api/sequence_animator/#destroy","title":":Destroy","text":"<pre><code>SequenceAnimatorInstance:Destroy(): ()\n</code></pre>"},{"location":"api/sequence_animator/#sequencetrack","title":"SequenceTrack","text":""},{"location":"api/sequence_animator/#properties","title":"Properties","text":""},{"location":"api/sequence_animator/#speed","title":"Speed","text":"<pre><code>SequenceTrack.Speed: number\n</code></pre> <p>When equal to 1, the amount of time an animation takes to complete is equal to Length, in seconds.</p> <p>Changing this property while animation is being played won't result in it speeding up / slowing down, instead next time Play is called the new speed will be applied.</p>"},{"location":"api/sequence_animator/#length","title":"Length","text":"<pre><code>SequenceTrack.Length: number\n</code></pre> <p>Length in seconds.</p> <p>Warning</p> <p>This property can be modified, but you shouldn't really have a reason to do so.</p>"},{"location":"api/sequence_animator/#isplaying","title":"IsPlaying","text":"<pre><code>SequenceTrack.IsPlaying: boolean\n</code></pre> <p>Returns true when SequenceTrack is playing an animation.</p>"},{"location":"api/sequence_animator/#looped","title":"Looped","text":"<pre><code>SequenceTrack.Looped: boolean\n</code></pre> <p>This property sets whether the animation will repeat after finishing.</p> <p>Changing this property while animation is being played won't result in it looping once it reaches the end, instead next time Play is called the new change will be applied.</p>"},{"location":"api/sequence_animator/#ended","title":"Ended","text":"<pre><code>SequenceTrack.Ended: RBXScriptSignal\n</code></pre> <p>Fires when the SequenceTrack is completely done moving anything in the world, meaning the animation has finished playing.</p>"},{"location":"api/sequence_animator/#didloop","title":"DidLoop","text":"<pre><code>SequenceTrack.DidLoop: RBXScriptSignal\n</code></pre> <p>This event fires whenever a looped SequenceTrack completes a loop.</p>"},{"location":"api/sequence_animator/#functions_2","title":"Functions","text":""},{"location":"api/sequence_animator/#play","title":":Play","text":"<pre><code>SequenceTrack:Play(): ()\n</code></pre> <p>When called the animation will start playing.</p> <p>Notice</p> <p>Currently SequenceAnimator doesn't support fadeTime and weight unlike Robloxes AnimationTrack.</p>"},{"location":"api/sequence_animator/#stop","title":":Stop","text":"<pre><code>SequenceTrack:Stop(): ()\n</code></pre> <p>Stops the current animation, if one is playing. Stopping an animation will not cause the pose to reset to its default state.</p> <p>Notice</p> <p>Currently SequenceAnimator doesn't support fadeTime and weight unlike Robloxes AnimationTrack.</p>"},{"location":"api/simple_store/","title":"API","text":""},{"location":"api/simple_store/#simplestore","title":"SimpleStore","text":"<p>An alternative DataStore library that focuses on simplicity over features.</p> <p>This DataStore library internally relies on the latest version of DubitStore, so your data will inherit all of the constraints and benefits DubitStore provides.</p>"},{"location":"api/simple_store/#functions","title":"Functions","text":""},{"location":"api/simple_store/#getplayerstore","title":"GetPlayerStore","text":"<pre><code>SimpleStore:GetPlayerStore(key: Player, datastoreName: string?): PlayerDataStore\n</code></pre> <p>Will get a PlaterDataStore instance based off of the parameter 'key' (key represents the Player!), optionally, if you would like to seperate player data from being in the same datastore, a second parameter is provided so you can define your own datastore.</p> <p>This will create a new PlayerDataStore if the player has not been allocated a PlayerDataStore already.</p> Example Usage <pre><code>local playerStore = SimpleStore:GetPlayerStore(player)\n\nplayerStore:Set({\n    progression = {\n        exp = 0,\n        level = 1\n    }\n})\nplayerStore:SetKey(\"progression.level\", 2)\n</code></pre>"},{"location":"api/simple_store/#playerdatastore","title":"PlayerDataStore","text":"<p>A simple wrapper for Player orientated datastores, this is the primary datastore object that developers will be interacting with, it's goal is to make the interaction between loading, saving and manipulating player datastores easier for developers.</p> <p>PlayerDataStore's also rely on Session Locking, after 60 seconds, the Session Lock will be overwritten so that the players data isn't stuck forever. A players data is only released when Destroy has been called from the active server.</p>"},{"location":"api/simple_store/#properties","title":"Properties","text":""},{"location":"api/simple_store/#changed","title":"Changed","text":"<pre><code>PlayerDataStore.Changed: Signal\n</code></pre>"},{"location":"api/simple_store/#isnewplayer","title":"IsNewPlayer","text":"<pre><code>PlayerDataStore.IsNewPlayer: boolean\n</code></pre>"},{"location":"api/simple_store/#id","title":"Id","text":"<pre><code>PlayerDataStore.Id: number\n</code></pre>"},{"location":"api/simple_store/#key","title":"Key","text":"<pre><code>PlayerDataStore.Key: string\n</code></pre>"},{"location":"api/simple_store/#autosaveid","title":"AutosaveId","text":"<pre><code>PlayerDataStore.AutosaveId: string\n</code></pre>"},{"location":"api/simple_store/#functions_1","title":"Functions","text":""},{"location":"api/simple_store/#get","title":":Get","text":"<pre><code>PlayerDataStore:Get(fallback: any): (any, boolean)\n</code></pre> <p>Danger</p> <p>This function yields.</p> <p>Get's the players data from datastore, provides a fallback so if no data is found, the fallback is returned instead.</p> Example Usage <pre><code>local defaultPlayerData = {\n    progression = {\n        experience = 0,\n        level = 0\n    }\n}\n\nlocal playerStore = SimpleStore:GetPlayerStore(player)\n\nlocal playerData = playerStore:Get(defaultPlayerData)\n</code></pre> <p>Warning</p> <p>There is no reconciliation happening in the background, meaning if a players data changes over time, there's no guarantee that the new data exists for older users.</p> <p>One of the ways of getting reconciliation is to use DubitUtils package and use DubitUtils.Table.mergeDeep to update old data with new data values!</p>"},{"location":"api/simple_store/#getkey","title":":GetKey","text":"<pre><code>PlayerDataStore:GetKey(path: string, fallback: any): any\n</code></pre> <p>Danger</p> <p>This function yields.</p> <p>If the players data represents a table, you can use this function to get specific parts of that players data.</p> Example Usage <pre><code>local defaultPlayerData = {\n    progression = {\n        experience = 0,\n        level = 0\n    }\n}\n\nlocal playerStore = SimpleStore:GetPlayerStore(player)\n\nplayerStore:Set(defaultPlayerData)\n\nlocal experience = playerStore:GetKey(\"progression.experience\", 0)\nlocal level = playerStore:GetKey(\"progression.level\", 1)\n</code></pre>"},{"location":"api/simple_store/#set","title":":Set","text":"<pre><code>PlayerDataStore:Set(data: any): ()\n</code></pre> <p>Danger</p> <p>This function yields.</p> <p>Overwrite the current players data with a new set of data.</p> Example Usage <pre><code>local playerStore = SimpleStore:GetPlayerStore(player)\n\nplayerStore:Set({ text = \"Hello, World!\" })\n\nprint(playerStore:GetKey(\"text\")) --&gt; Hello, World!\n\nplayerStore:Set({ text = \"Hello, Something else!\" })\n\nprint(playerStore:GetKey(\"text\")) --&gt; Hello, Something else!\n</code></pre>"},{"location":"api/simple_store/#setkey","title":":SetKey","text":"<pre><code>PlayerDataStore:SetKey(path: string, data: any): ()\n</code></pre> <p>Danger</p> <p>This function yields.</p> <p>If the players data represents a table, you can use this function to overwrite specific parts of that players data.</p> Example Usage <pre><code>local playerStore = SimpleStore:GetPlayerStore(player)\n\nplayerStore:Set({\n    pets = {\n        currentAnimal = {\n            animalName = \"Fluffy\"\n        }\n    }\n})\n\nprint(playerStire:GetKey(\"pets.currentAnimal.animalName\")) --&gt; Fluffy\nplayerStore:SetKey(\"pets.currentAnimal.animalName\", \"Joey\")\nprint(playerStire:GetKey(\"pets.currentAnimal.animalName\")) --&gt; Joey\n</code></pre>"},{"location":"api/simple_store/#merge","title":":Merge","text":"<pre><code>PlayerDataStore:Merge(tableToBeMerged: { [any]: any }): ()\n</code></pre> <p>Danger</p> <p>This function yields.</p> <p>Merge the current player data with an input table, the input table takes priority so it'll overwrite keys in the current player data.</p> Example Usage <pre><code>local playerStore = SimpleStore:GetPlayerStore(player)\n\nplayerStore:Set({\n    text = \"Hello, World!\",\n    boolean = true\n})\n\nprint(playerStire:GetKey(\"text\")) --&gt; Hello, World!\nprint(playerStire:GetKey(\"boolean\")) --&gt; true\n\nplayerStore:Merge({\n    text = \"Hello, Something else!\"\n})\n\nprint(playerStire:GetKey(\"text\")) --&gt; Hello, Something else!\nprint(playerStire:GetKey(\"boolean\")) --&gt; true\n</code></pre>"},{"location":"api/simple_store/#mergekey","title":":MergeKey","text":"<pre><code>PlayerDataStore:MergeKey(path: string): ()\n</code></pre> <p>Danger</p> <p>This function yields.</p> <p>If the players data represents a table, you can use this function to merge tables under the player data together, the input table takes priority so it'll overwrite keys in the current player data.</p> Example Usage <pre><code>local playerStore = SimpleStore:GetPlayerStore(player)\n\nplayerStore:Set({\n    pets = {\n        currentAnimal = {\n            animalName = \"Fluffy\",\n            animalLevel = 0,\n            animalExperience = 0,\n        }\n    }\n})\n\nprint(playerStore:GetKey(\"pets.currentAnimal.animalLevel\")) --&gt; 0\nprint(playerStore:GetKey(\"pets.currentAnimal.animalName\")) --&gt; Fluffy\n\nplayerStore:MergeKey(\"pets.currentAnimal\", {\n    animalLevel = 1\n})\n\nprint(playerStore:GetKey(\"pets.currentAnimal.animalLevel\")) --&gt; 1\nprint(playerStore:GetKey(\"pets.currentAnimal.animalName\")) --&gt; Fluffy\n</code></pre>"},{"location":"api/simple_store/#update","title":":Update","text":"<pre><code>PlayerDataStore:Update(transformFunction: ((serverData: any) -&gt; any)): ()\n</code></pre> <p>Danger</p> <p>This function yields.</p> <p>Given a transform function, this function will call the transform function with the most up-to-date player data, and will save the return of the transform function.</p> Example Usage <pre><code>local playerStore = SimpleStore:GetPlayerStore(player)\n\nplayerStore:Update(function(latestPlayerData)\n    latestPlayerData.SomethingHasChnaged = true\n\n    return latestPlayerData\nend)\n</code></pre>"},{"location":"api/simple_store/#updatekey","title":":UpdateKey","text":"<pre><code>PlayerDataStore:UpdateKey(path: string, transformFunction: ((serverData: any) -&gt; any)): ()\n</code></pre> <p>Danger</p> <p>This function yields.</p> <p>Given a transform function, this function will call the transform function with the most up-to-date player data, and will save the return of the transform function.</p> Example Usage <pre><code>local playerStore = SimpleStore:GetPlayerStore(player)\n--[[\n    {\n        pets = {\n            currentAnimal = {\n                animalName = \"Fluffy\",\n                animalLevel = 0,\n                animalExperience = 0,\n            }\n        }\n    }\n]]\n\nplayerStore:UpdateKey(\"pets.currentAnimal\", function(currentAnimalData)\n    currentAnimalData.animalName = \"Joey\"\n\n    return currentAnimalData\nend)\n</code></pre>"},{"location":"api/simple_store/#save","title":":Save","text":"<pre><code>PlayerDataStore:Save(): ()\n</code></pre> <p>Danger</p> <p>This function yields.</p> <p>Save the player data to datastore.</p>"},{"location":"api/simple_store/#destroy","title":":Destroy","text":"<pre><code>PlayerDataStore:Destroy(): ()\n</code></pre> <p>Danger</p> <p>This function yields.</p> <p>Destroys this player data's instance on this server. Should be called when the player leaves the game.</p>"},{"location":"api/totalizers/","title":"API","text":""},{"location":"api/totalizers/#properties","title":"Properties","text":""},{"location":"api/totalizers/#totalizerupdated","title":"TotalizerUpdated","text":"<pre><code>Totalizers.TotalizerUpdated: Signal&lt;string, number&gt;\n</code></pre> <p>Invoked when a totalizer value is updated, either by the server the script is running on or by another server within the experience if SetBroadcastingEnabled is enabled (which it is by default).</p> <p>This is a server only property.</p>"},{"location":"api/totalizers/#methods","title":"Methods","text":""},{"location":"api/totalizers/#getasync","title":":GetAsync","text":"<pre><code>Totalizers:GetAsync(identifier: string): number\n</code></pre> <p>Returns the current value of the totalizer.</p> <p>This is a server only method.</p>"},{"location":"api/totalizers/#incrementasync","title":":IncrementAsync","text":"<pre><code>Totalizers:IncrementAsync(identifier: string, incrementBy: number? = 1): (boolean, number)\n</code></pre> <p>Increments the current value of the totalizer. Returns true followed by the new value if the increment was successful.</p> <p>This is a server only method.</p>"},{"location":"api/totalizers/#resetasync","title":":ResetAsync","text":"<pre><code>Totalizers:ResetAsync(identifier: string): boolean\n</code></pre> <p>Resets the current value of the totalizer to 0. Returns true when successful.</p> <p>This is a server only method.</p>"},{"location":"api/totalizers/#setupdaterate","title":":SetUpdateRate","text":"<pre><code>Totalizers:SetUpdateRate(updateRate: number = &gt;=30): ()\n</code></pre> <p>Sets the current update rate.</p> <p>Default: 60 seconds</p> <p>This is a server only method.</p>"},{"location":"api/totalizers/#getupdaterate","title":":GetUpdateRate","text":"<pre><code>Totalizers:GetUpdateRate(): number\n</code></pre> <p>Returns the current update rate.</p> <p>Default: 60 seconds</p> <p>This is a server only method.</p>"},{"location":"api/totalizers/#setbroadcastingenabled","title":":SetBroadcastingEnabled","text":"<pre><code>Totalizers:SetBroadcastingEnabled(enabled: boolean): ()\n</code></pre> <p>Enables or disables the broadcasting feature. When enabled, updates to totalizer values are sent between servers, resulting in more responsive and accurate totalizer values across the entire experience.</p> <p>This is a server only method.</p>"},{"location":"packages/allocation_pool/","title":"Overview","text":"<p>You can add the AllocationPool library to your project by adding the following into your <code>wally.toml</code> file.</p> <pre><code>[place]\nshared-packages = \"game.ReplicatedStorage.Packages\"\n\n[server-dependencies]\nAllocationPool = \"dubit/allocation-pool@^0\"\n</code></pre>"},{"location":"packages/allocation_pool/#what-is-the-allocation-pool-package","title":"What is the Allocation Pool package?","text":"<p>The goal for this package is to provide developers with an easy way to create globally synced budgets. A budget in this scenario represents an array of items that can be consumed - and we want to make sure only X items are consumed, nothing more.</p> <p>The allocation pool offers the following features;</p> <ul> <li>Consuming Global Budgets</li> <li>Manipulating Global Budgets</li> <li>Counting how many items are left in a budget</li> </ul>"},{"location":"packages/allocation_pool/#examples","title":"Examples","text":"<p>The below example details how to create a pool with a limit:</p> <pre><code>local AllocationPool = require(path.to.module)\n\n-- Create a pool named \"MyPool\" with a limit of 100 allocations\nAllocationPool.CreatePoolAsync(\"MyPool\", 100):expect()\n</code></pre> <p>The below example shows how to consume from a pool and award an item:</p> <pre><code>local AllocationPool = require(path.to.module)\n\n-- Consume 1 allocation from \"MyPool\" for the given player\nAllocationPool.ConsumePoolAsync(player, \"MyPool\")\n    :andThen(function()\n        -- Pool was successfully consumed, award the item\n        self:AwardPlayerUGCAsync(player, \"ugcId\"):await()\n    end)\n    :catch(function(err)\n        warn(\"Failed to award item to \" .. player.Name .. \" - \" .. err)\n    end)\n\n-- You can also consume anonymously without tracking per-player\nAllocationPool.ConsumePoolAsync(nil, \"MyPool\")\n    :andThen(function()\n        -- Pool was successfully consumed\n        self:AwardPlayerUGCAsync(player, \"ugcId\"):await()\n    end)\n    :catch(function(err)\n        warn(\"Failed to award item - \" .. err) \n    end)\n</code></pre> <p>Other useful functions:</p> <pre><code>-- Get remaining allocations in a pool\nlocal remaining = AllocationPool.GetPoolReserveAsync(\"MyPool\"):expect()\n\n-- Get total consumed allocations\nlocal consumed = AllocationPool.GetPoolCountAsync(\"MyPool\"):expect()\n\n-- Check if a player has consumed from a pool\nlocal hasConsumed = AllocationPool.HasConsumedAsync(player, \"MyPool\"):expect()\n\n-- Reset a pool's consumption back to 0\nAllocationPool.ResetPoolAsync(\"MyPool\"):expect()\n\n-- Update a pool's limit\nAllocationPool.UpdatePoolLimitAsync(\"MyPool\", 200):expect()\n</code></pre>"},{"location":"packages/allocation_pool/#practical-example","title":"Practical Example","text":"<p>Below is an example of how you'd use the allocation pool to award players 10 items per day.</p> <pre><code>local AllocationPool = require(path.to.AllocationPool)\n\n-- Create a pool for today with a limit of 10 items\nlocal function getDailyPoolName(offset)\n    local date = os.date(\"*t\", os.time() - (offset or 0) * 86400)\n    return string.format(\"DailyPool_%d_%d_%d\", date.year, date.month, date.day)\nend\n\n-- When server starts, create/ensure today's pool exists\nlocal function initializeDailyPool()\n    local yesterdayPool = getDailyPoolName(1)\n    local todayPool = getDailyPoolName()\n\n    return AllocationPool.GetPoolReserveAsync(yesterdayPool)\n        :andThen(function(remainingFromYesterday)\n            return AllocationPool.CreatePoolAsync(todayPool, 10 + remainingFromYesterday)\n        end)\n        :catch(function()\n            -- If yesterday's pool doesn't exist, just create with base limit\n            return AllocationPool.CreatePoolAsync(todayPool, 10)\n        end)\nend\n\n-- Function to try award an item to a player\nlocal function tryAwardDailyItem(player)\n    local poolName = getDailyPoolName()\n\n    -- Check if player already received their daily item\n    return Promise.new(function(resolve, reject)\n        AllocationPool.HasConsumedAsync(player, poolName)\n            :andThen(function(hasConsumed)\n                if hasConsumed then\n                    return reject(\"Already claimed today's item\")\n                end\n\n                -- Try to consume from today's pool\n                return AllocationPool.ConsumePoolAsync(player, poolName)\n                    :andThen(function()\n                        resolve()\n                    end)\n                    :catch(reject)\n            end)\n            :catch(reject)\n    end)\nend\n</code></pre>"},{"location":"packages/anticheat/","title":"Overview","text":"<p>The AntiCheat package is designed to help developers implement a quick, standard anti-cheat system into their Roblox experiences. It provides tools to detect common exploits and allows developers to track and respond to instances of cheating.</p>"},{"location":"packages/anticheat/#adding-anticheat-to-a-project","title":"Adding AntiCheat to a Project","text":"<p>To add the <code>AntiCheat</code> package to your project, add the following to your <code>wally.toml</code> file:</p> <pre><code>[dependencies]\nAntiCheat = \"dubit/anticheat@0.x.x\" -- Replace with the actual version\n</code></pre>"},{"location":"packages/anticheat/#principles","title":"Principles","text":"<p>The AntiCheat package is built upon the following principles:</p> <ul> <li>Ease of Use: Provides a simple and straightforward API for implementing anti-cheat measures.</li> <li>Configurability: Allows developers to enable or disable different anti-cheat components without significantly affecting the player's experience.</li> <li>Extensibility: Offers a way for developers to track and respond to instances of cheating.</li> <li>Performance: Designed to minimize performance impact on the game.</li> </ul>"},{"location":"packages/anticheat/#usage","title":"Usage","text":"<p>To use the AntiCheat package, you'll typically follow these steps:</p> <ol> <li>Require the Module: Require the <code>AntiCheat</code> module in your script.</li> <li>Listen for Cheaters: Connect a function to the <code>CheaterFound</code> signal to be notified when a player is detected as a cheater.</li> <li>Listen for Violations: (Optional) Connect a function to the <code>ViolationTriggered</code> signal to be notified when a player triggers a rule violation.</li> <li>Configure Nodes: (Optional) Disable or enable specific anti-cheat nodes using the <code>DisableNode</code> and <code>EnableNode</code> methods.</li> <li>Set Flags: (Optional) Configure specific flags for the anti-cheat nodes using the <code>SetFlag</code> method.</li> </ol> <p>Here's a basic example of how to use the AntiCheat package:</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal AntiCheat = require(ReplicatedStorage.Packages.AntiCheat)\n\n-- Listen for cheaters\nAntiCheat.CheaterFound:Connect(function(player)\n    print(`{player.Name} was detected as a cheater!`)\nend)\n\n-- Listen for violations\nAntiCheat.ViolationTriggered:Connect(function(player, node, message)\n    print(`{player.Name} violated {node}: {message}`)\nend)\n</code></pre>"},{"location":"packages/anticheat/#examples","title":"Examples","text":""},{"location":"packages/anticheat/#disabling-a-node","title":"Disabling a Node","text":"<pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal AntiCheat = require(ReplicatedStorage.Packages.AntiCheat)\n\n-- Disable the AntiFly node\nAntiCheat:DisableNode(AntiCheat.Nodes.AntiFly)\n</code></pre>"},{"location":"packages/anticheat/#enabling-a-node","title":"Enabling a Node","text":"<pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal AntiCheat = require(ReplicatedStorage.Packages.AntiCheat)\n\n-- Enable the AntiFly node\nAntiCheat:EnableNode(AntiCheat.Nodes.AntiFly)\n</code></pre>"},{"location":"packages/anticheat/#setting-a-flag","title":"Setting a Flag","text":"<pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal AntiCheat = require(ReplicatedStorage.Packages.AntiCheat)\n\n-- Set the RaycastDistance flag for the AntiFly node\nAntiCheat:SetFlag(AntiCheat.Nodes.AntiFly.RaycastDistance, 1.5)\n</code></pre>"},{"location":"packages/anticheat/#whitelisting-a-player","title":"Whitelisting a Player","text":"<pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\n\nlocal AntiCheat = require(ReplicatedStorage.Packages.AntiCheat)\n\nPlayers.PlayerAdded:Connect(function(player: Player)\n    if player.UserId == 123456 then\n        -- Add a player to the whitelist\n        AntiCheat:AddToWhitelist(player)\n    end\nend)\n</code></pre>"},{"location":"packages/anticheat/#checking-if-a-player-is-flagged-as-a-cheater","title":"Checking if a Player is Flagged as a Cheater","text":"<pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\n\nlocal AntiCheat = require(ReplicatedStorage.Packages.AntiCheat)\n\nPlayers.PlayerAdded:Connect(function(player: Player)\n    -- Check if a player is flagged as a cheater\n    local isCheater = AntiCheat:IsFlaggedAsCheater(player)\n\n    if isCheater then\n        print(`{player.Name} is flagged as a cheater!`)\n    end\nend)\n</code></pre>"},{"location":"packages/bolt/","title":"Overview","text":"<p>Bolt is a networking package designed to provide strong type safety for networking in Roblox experiences. It originally began as a simple code snippet, which is why it has no external dependencies and fully contained within a single file.</p> <p>The goal is to simplify networking and get good type checking, decent message size and optional serialization / deserialization. The default serializer is built to handle most of the data developers commonly send, and custom serializers are generally only needed when further reducing message size or optimizing for very specialized cases.</p>"},{"location":"packages/bolt/#adding-bolt-to-a-project","title":"Adding Bolt to a Project","text":"<p>To add the Bolt package to your project, add the following to your wally.toml file:</p> <pre><code>[dependencies]\nSequenceAnimator = \"dubit/bolt@^0\"\n</code></pre>"},{"location":"packages/bolt/#examples","title":"Examples","text":"Example Usage - ReliableEvent Networking.luauServer.luauClient.luau <pre><code>return {\n    Messages = Bolt.ReliableEvent(\"Messages\") :: Bolt.ReliableEvent&lt;string&gt;,\n}\n</code></pre> <pre><code>Networking.Messages.OnServerEvent:Connect(function(player, message)\n    print(`{player.DisplayName} says {message}`) --&gt; Username says Hello world!\nend)\n</code></pre> <pre><code>Networking.Messages:FireServer(\"Hello world!\")\n</code></pre> Example Usage - RemoteFunction Networking.luauServer.luauClient.luau <pre><code>return {\n    PurchaseItem = Bolt.RemoteFunction(\"PurchaseItem\") :: Bolt.RemoteFunction&lt;(string), (boolean)&gt;,\n}\n</code></pre> <pre><code>Networking.PurchaseItem.OnServerInvoke = function(player, item)\n    if typeof(item) ~= \"string\" then\n        return false\n    end\n\n    -- some logic\n\n    return true\nend\n</code></pre> <pre><code>local success = Networking.PurchaseItem:InvokeServer(\"apple\")\n</code></pre> Example Usage - RemoteProperty Networking.luauServer.luauClient.luau <pre><code>return {\n    GoldBalance = Bolt.RemoteProperty(\"GoldBalance\", 0) :: Bolt.RemoteProperty&lt;number&gt;,\n}\n</code></pre> <pre><code>local function playerAdded(player: Player)\n    Networking.GoldBalance:SetFor(player, 5)\nend\n\nPlayers.PlayerAdded:Connect(playerAdded)\nfor _, player in Players:GetPlayers() do\n    task.spawn(playerAdded, player)\nend\n</code></pre> <pre><code>Networking.GoldBalance:Observe(function(newValue)\n    print(newValue)\nend)\n\n--&gt; 0\n--&gt; 5\n</code></pre> Example Usage - Custom serialization <p>Let's say in this example we know that player won't ever have more than 255 bullets in his weapon, we can optimize the message generated by this remote event as the default serializer used internally by Bolt uses 64bit floating point numbers, which are 8 bytes in size, 255 fits within one byte so we can serialize the number into one byte using unsigned 8bit integer and then deserialize it when we receive the given message.</p> <p>With this simple optimization we've decreased our message size by 87.5%! <pre><code>return {\n    PlayerAmmo = Bolt.ReliableEvent(\"PlayerAmmo\", function(bufferWriter: BufferWriter, amount: number)\n        bufferWriter:WriteU8()\n    end, function(bufferReader: BufferReader)\n        return bufferReader:ReadU8()\n    end) :: Bolt.ReliableEvent&lt;number&gt;,\n}\n</code></pre></p> Example Usage - More complex custom serialization <p>Bolt by default doesn't have a way of serializing ColorSequences, but you can add that functionality using a custom seralization and deserialization!</p> <pre><code>Bolt.ReliableEvent(\"Color Sequence Event\", function(writer, colorSequence: ColorSequence)\n    writer:WriteU8(#colorSequence.Keypoints)\n    for _, keypoint in colorSequence.Keypoints do\n        writer:WriteU8(math.clamp(keypoint.Time * 255, 0, 255))\n        writer:WriteColor3(keypoint.Value)\n    end\nend, function(reader)\n    local keypointsCount = reader:ReadU8()\n    local keypoints = table.create(keypointsCount)\n    for i = 1, keypointsCount do\n        local keypointTime = reader:ReadU8() / 255\n        local keypointsColor = reader:ReadColor3()\n        table.insert(keypoints, ColorSequenceKeypoint.new(keypointTime, keypointsColor))\n    end\n    return ColorSequence.new(keypoints)\nend) :: Bolt.ReliableEvent&lt;ColorSequence&gt;\n</code></pre>"},{"location":"packages/debug_tools/","title":"Overview","text":""},{"location":"packages/debug_tools/#adding-debug-tools-to-a-project","title":"Adding Debug Tools to a Project","text":"<p>To add <code>Debug Tools</code> package to your project add the following into your <code>wally.toml</code> file.</p> <p>Notice</p> <p>The package doesn't need to be required within another script to be initialized, the package does it by itself.</p> <pre><code>[dependencies]\nDebugTools = \"dubit/debug-tools@~1.1.0\"\n</code></pre> <p>Warning</p> <p>DebugTools package may not work as expected if required from within an Actor</p> <p>This is because the module self-initialises from a default non-actor context</p>"},{"location":"packages/debug_tools/#actions","title":"Actions","text":""},{"location":"packages/debug_tools/#introduction","title":"Introduction","text":"<p>The concept of \"Actions\" aims to replace traditional chat commands with a more user-friendly and efficient alternative. An action can have optional arguments, there are two types of actions; Serverside and Clientside both marked within the Debug Tools interface under <code>Actions</code> tab, the only difference between both of these is in which environment the execution happens.</p>"},{"location":"packages/debug_tools/#defining-an-action","title":"Defining an Action","text":"<p>Actions can be defined on both the client and the server, but they may only be executed by authorized users. Because malicious actors can modify their clients to trigger client-side actions, authorization is always enforced. If an unauthorized user attempts to perform an action, they are immediately kicked from the server.</p> <p>The execution environment depends on where the action is defined, an action defined from a server script runs on the server and an action defined from a client script runs on the client.</p> <p>Example: <pre><code>DebugTools.Action.new(\"Print message\", nil, function()\n    print(\"Hello world!\")\nend)\n</code></pre></p>"},{"location":"packages/debug_tools/#gotchas","title":"Gotchas","text":"<p>An action can also have arguments, all of the arguments need to have a type specified, while the rest; <code>Name</code>, <code>Description</code> and <code>Default</code> are optional.</p> <p>Example:</p> <pre><code>DebugTools.Action.new(\"Trigger Race\", nil, function(track: string, laps: number, spawnCar: boolean)\n    -- ... logic for triggering the race\nend, {\n    {\n        Type = \"string\",\n        Name = \"track\",\n        Default = \"Quick Track\",\n    },\n    {\n        Type = \"number\",\n        Name = \"laps\",\n        Default = 4,\n    },\n    {\n        Type = \"boolean\",\n        Name = \"spawn car\",\n    }\n})\n</code></pre> <pre><code>DebugTools.Action.new(\"Set Money\", \"Sets player money to a given amount\", function(player: Player, amount: number)\n    -- ... logic for setting the money\nend, {\n    {\n        Type = \"Player\",\n        Name = \"player\",\n    },\n    {\n        Type = \"number\",\n        Name = \"amount\",\n        Default = 1000\n    }\n})\n</code></pre>"},{"location":"packages/debug_tools/#tabs","title":"Tabs","text":""},{"location":"packages/debug_tools/#introduction_1","title":"Introduction","text":"<p>Tabs are sections within the interface of Debug Tools, while Widgets primarily serve the purpose of data presentation, Tabs are specifically designed to facilitate interaction. The interface features a selection of predefined tabs, each serving distinct functions but developers can also add their own tabs if they want to.</p>"},{"location":"packages/debug_tools/#defining-a-tab","title":"Defining a Tab","text":"<pre><code>DebugTools.Tab.new(\"My Tab\", function(parent) -- this is a constructor function\n    local tabContent = Instance.new(\"Frame\")\n    tabContent.Parent = parent\n\n    -- ... some tab logic\n\n    return function() -- this is a destructor function\n        tabContent:Destroy()\n    end\nend)\n</code></pre>"},{"location":"packages/debug_tools/#widgets","title":"Widgets","text":""},{"location":"packages/debug_tools/#introduction_2","title":"Introduction","text":"<p>Widgets are on screen elements that can be any size and anywhere on the screen as well as hidden completely. The primary purpose of widgets is to swiftly convey information without requiring the opening of a separate interface and their sole function is to display non-interactive data.</p> <p>Widgets shouldn't disrupt or interfere with gameplay elements.</p>"},{"location":"packages/debug_tools/#repositioning-widgets","title":"Repositioning widgets","text":"<ul> <li>Press F6 to open the Widgets tab.</li> <li>Locate your desired widget within the square representing your screen.</li> <li>Click and hold the left mouse button on the widget.</li> <li>Drag the widget within the square area that represents your screen.</li> <li>Release the left mouse button to set the widget's new position.</li> </ul>"},{"location":"packages/debug_tools/#enabling-or-disabling-widgets","title":"Enabling or disabling widgets","text":"<ul> <li>Open the Widgets tab by pressing F6.</li> <li>In the Widgets tab, you'll find a list of available widgets on the right side.</li> <li>To enable a widget, locate it in the list. A green entry signifies that the widget is already enabled.</li> <li>To disable a widget, find it in the list. A red entry indicates that the widget is currently disabled.</li> </ul>"},{"location":"packages/debug_tools/#defining-a-new-widget","title":"Defining a new widget","text":"<p>Every widget has a constructor function that needs to return a destructor function, the constructor function gets executed whenever the widget gets shown whereas the destructor is executed whenever the widget gets hidden. Here is an example implementation of a Widget:</p> <pre><code>DebugTools.Widget.new(\"Cool Widget\", function(parent) -- this is a constructor function\n    local widgetContent = Instance.new(\"Frame\")\n    widgetContent.Parent = parent\n\n    -- ... some widget logic\n\n    return function() -- this is a destructor function\n        widgetContent:Destroy()\n    end\nend)\n</code></pre>"},{"location":"packages/dubit_store/","title":"Overview","text":"<p>You can add the DubitStore package to your project by adding the following into your <code>wally.toml</code> file.</p> <pre><code>[place]\nshared-packages = \"game.ReplicatedStorage.Packages\"\n\n[server-dependencies]\nDubitStore = \"dubit/dubit-store@^1\"\n</code></pre>"},{"location":"packages/dubit_store/#dubitstore-principles","title":"DubitStore Principles","text":"<p>DubitStore is based on cache, setting data will NOT save that data, it will only set that data in cache, allowing developers to quickly write and read. To push changes made in the cache, use the PushAsync method.</p> <p>Notice</p> <p>It is important that cache is cleared for player data once a player leaves.</p>"},{"location":"packages/dubit_store/#dubitstore-examples","title":"DubitStore Examples","text":"<p>Loading Data Example: <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal DubitStore = require(ReplicatedStorage.Packages.DubitStore)\n\nDubitStore:CreateDataSchema(\"Schema\", {\n    [\"Gold\"] = DubitStore.Container.new(5)\n})\n\nDubitStore:GetDataAsync(\"DataStore\", \"Example\"):andThen(function(data)\n    data = DubitStore:ReconcileData(data, \"Schema\")\n\n    print(data)\nend)\n</code></pre></p> <p>Setting Data Example: <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal DubitStore = require(ReplicatedStorage.Packages.DubitStore)\n\nDubitStore:SetDataAsync(\"DataStore\", \"Example\", {\n    Data = \"Hello, World!\"\n}):andThen(function()\n    DubitStore:PushAsync(\"DataStore\", \"Example\"):andThen(function()\n        DubitStore:ClearCache(\"DataStore\", \"Example\")\n        -- if this is player data, we want to remove cache so when that player rejoins this server,\n        -- we have an updated version of that players data.\n\n        print(\"Data has been saved!\")\n    end)\nend)\n</code></pre></p>"},{"location":"packages/dubit_store/#advanced-dubitstore-examples","title":"Advanced DubitStore Examples","text":"<p>Loading Data with Session Locking <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal DubitStore = require(ReplicatedStorage.Packages.DubitStore)\n\nDubitStore:CreateDataSchema(\"Schema\", {\n    [\"Gold\"] = DubitStore.Container.new(5)\n})\n\nDubitStore:YieldUntilDataUnlocked(\"DataStore\", \"Example\")\nDubitStore:GetDataAsync(\"DataStore\", \"Example\"):andThen(function(data)\n    data = DubitStore:ReconcileData(data, \"Schema\")\n\n    warn(\"Got:\", data)\nend):andThen(function()\n    DubitStore:SetDataSessionLocked(\"DataStore\", \"Example\", true)\n    DubitStore:PushAsync(\"DataStore\", \"Example\", { player }):andThen(function()\n        print(\"Locked Player Data!\")\n    end)\nend)\n</code></pre></p> <p>Saving Data with Session Locking <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal DubitStore = require(ReplicatedStorage.Packages.DubitStore)\n\nDubitStore:SetDataSessionLocked(\"DataStore\", \"Example\", false)\nDubitStore:PushAsync(\"DataStore\", \"Example\", { player }):andThen(function()\n    DubitStore:ClearCache(\"DataStore\", \"Example\")\n    -- if this is player data, we want to remove cache so when that player rejoins this server,\n    -- we have an updated version of that players data.\n\n    warn(\"Saved Player Data!\")\nend)\n</code></pre></p>"},{"location":"packages/dubit_utils/","title":"Overview","text":"<p>DubitUtils is a collection of utility functions and modules designed to simplify common tasks in Roblox development. It provides a range of tools for various purposes, such as camera manipulation, character management, data buffering, and more.</p>"},{"location":"packages/dubit_utils/#adding-dubitutils-to-a-project","title":"Adding DubitUtils to a Project","text":"<p>To add the <code>DubitUtils</code> package to your project, add the following to your <code>wally.toml</code> file:</p> <pre><code>[dependencies]\nDubitUtils = \"dubit/dubit-utils@0.x\" -- Replace with the actual version\n</code></pre>"},{"location":"packages/dubit_utils/#principles","title":"Principles","text":"<p>DubitUtils is built upon the following principles:</p> <ul> <li>Modularity: Provides a set of independent modules that can be used individually.</li> <li>Reusability: Offers functions and modules that can be easily reused across different projects.</li> <li>Efficiency: Aims to provide optimized and performant utility functions.</li> <li>Simplicity: Focuses on providing simple and easy-to-use tools.</li> </ul>"},{"location":"packages/dubit_utils/#usage","title":"Usage","text":"<p>To use DubitUtils, you can require the main module and then access its sub-modules or functions. Here's a basic example:</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal DubitUtils = require(ReplicatedStorage.Packages.DubitUtils)\n\n-- Example usage of a sub-module (e.g., Camera)\nlocal CameraUtils = DubitUtils.Camera\n\n-- Example usage of a function from the Camera module\nlocal currentCamera = workspace.CurrentCamera\nlocal cameraPosition = CameraUtils.zoomToExtents(currentCamera, workspace.Model)\nprint(\"Camera Position:\", cameraPosition)\n</code></pre>"},{"location":"packages/dubit_utils/#examples","title":"Examples","text":"<p>Character Utilities</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal DubitUtils = require(ReplicatedStorage.Packages.DubitUtils)\n\n-- Sets the local player's character to frozen\nlocal player = game.Players.LocalPlayer\nlocal character = player.Character or player.CharacterAdded:Wait()\n\nDubitUtils.Character.setCharacterFrozen(Players.LocalPlayer.Character, true)\n</code></pre> <p>Buffer Reader/Writer</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal DubitUtils = require(ReplicatedStorage.Packages.DubitUtils)\n\nlocal BufferWriter = DubitUtils.BufferWriter\nlocal BufferReader = DubitUtils.BufferReader\n\n-- Create a new buffer writer\nlocal writer = BufferWriter.new()\n\n-- Write some data to the buffer\nwriter.Writei16(123)\nwriter.WriteString(\"Hello, World!\")\n\n-- Get the buffer as a string\nlocal buffer = writer:GetBuffer()\n\n-- Create a new buffer reader\nlocal reader = BufferReader.new(buffer)\n\n-- Read the data from the buffer\nlocal intValue = reader.Readi16()\nlocal stringValue = reader.ReadString()\n\nprint(\"Int Value:\", intValue)\nprint(\"String Value:\", stringValue)\n</code></pre>"},{"location":"packages/engagements/","title":"Overview","text":"<p>The Engagements package is designed to help developers easily track and handle player engagements with various elements within a Roblox experience. It provides tools for tracking interactions with zones, objects, videos, and GUIs, allowing for detailed analysis of player behavior.</p>"},{"location":"packages/engagements/#adding-engagements-to-a-project","title":"Adding Engagements to a Project","text":"<p>To add the <code>Engagements</code> package to your project, add the following to your <code>wally.toml</code> file:</p> <pre><code>[dependencies]\nEngagements = \"dubit/engagements@0.x.x\" -- Replace with the actual version\n</code></pre>"},{"location":"packages/engagements/#principles","title":"Principles","text":"<p>The Engagements package is built upon the following principles:</p> <ul> <li>Ease of Use: Provides a simple and straightforward API for tracking player engagements.</li> <li>Versatility: Supports tracking engagements with zones, objects, videos, and GUIs.</li> <li>Client-Server Communication: Uses client-server communication to accurately track and record engagements.</li> <li>IAB Compliance: Adheres to IAB (Interactive Advertising Bureau) guidelines for viewability and engagement metrics.</li> </ul>"},{"location":"packages/engagements/#usage","title":"Usage","text":"<p>To use the Engagements package, you'll typically follow these steps:</p> <ol> <li>Require the Module: Require the <code>Engagements</code> module in your script.</li> <li>Initialize the Package: Call the <code>Engagements:Initialize()</code> function to set up the necessary event listeners and tracking systems.</li> <li>Track Elements: Use the <code>TrackZone()</code>, <code>TrackObject()</code>, <code>TrackVideo()</code>, and <code>TrackGui()</code> functions to start tracking engagements with specific elements in your game.</li> <li>Listen for Events: Connect functions to the <code>ZoneEntered</code>, <code>ZoneLeft</code>, <code>WatchedVideo</code>, <code>ViewedGui</code>, and <code>InteractedWithGui</code> signals to be notified when specific engagement events occur.</li> </ol> <p>Here's a basic example of how to use the Engagements package:</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal Engagements = require(ReplicatedStorage.Packages.Engagements)\n\n-- Initialize the Engagements package\nEngagements:Initialize()\n\n-- Track a zone\nlocal zone = workspace.MyZone\nEngagements:TrackZone(zone, \"MyZoneIdentifier\")\n\n-- Listen for zone entered event\nEngagements.ZoneEntered:Connect(function(player, identifier)\n    print(player.Name .. \" entered zone: \" .. identifier)\nend)\n</code></pre>"},{"location":"packages/engagements/#examples","title":"Examples","text":""},{"location":"packages/engagements/#tracking-a-zone","title":"Tracking a Zone","text":"<pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal Engagements = require(ReplicatedStorage.Packages.Engagements)\n\n-- Assuming you have a zone named \"MyZone\" in the workspace\nlocal zone = workspace.MyZone\nEngagements:TrackZone(zone, \"MyZoneIdentifier\")\n</code></pre>"},{"location":"packages/engagements/#tracking-an-object","title":"Tracking an Object","text":"<pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal Engagements = require(ReplicatedStorage.Packages.Engagements)\n\n-- Assuming you have an object named \"MyObject\" in the workspace\nlocal object = workspace.MyObject\nEngagements:TrackObject(object, \"MyObjectIdentifier\")\n</code></pre>"},{"location":"packages/engagements/#tracking-a-video","title":"Tracking a Video","text":"<pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal Engagements = require(ReplicatedStorage.Packages.Engagements)\n\n-- Assuming you have a VideoFrame named \"MyVideo\" in the part\nlocal video = workspace.VideoPart.MyVideo\nEngagements:TrackVideo(video, \"MyVideoIdentifier\")\n</code></pre>"},{"location":"packages/engagements/#tracking-a-gui","title":"Tracking a GUI","text":"<pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\n\nlocal Engagements = require(ReplicatedStorage.Packages.Engagements)\n\n-- Assuming you have a ScreenGui named \"MyGui\" in PlayerGui\nlocal player = Players.LocalPlayer\nlocal playerGui = player:WaitForChild(\"PlayerGui\")\nlocal gui = playerGui:WaitForChild(\"MyGui\")\nEngagements:TrackGui(gui, \"MyGuiIdentifier\")\n</code></pre>"},{"location":"packages/engagements/#listening-for-a-watched-video-event","title":"Listening for a Watched Video Event","text":"<pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal Engagements = require(ReplicatedStorage.Packages.Engagements)\n\nEngagements.WatchedVideo:Connect(function(player, identifier)\n    print(player.Name .. \" watched video: \" .. identifier)\nend)\n</code></pre>"},{"location":"packages/engagements/#listening-for-a-gui-interaction-event","title":"Listening for a GUI Interaction Event","text":"<pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal Engagements = require(ReplicatedStorage.Packages.Engagements)\n\nEngagements.InteractedWithGui:Connect(function(player, identifier)\n    print(player.Name .. \" interacted with GUI: \" .. identifier)\nend)\n</code></pre>"},{"location":"packages/event_tracker/","title":"Overview","text":"<p>You can add the Event Tracker package to your project by adding the following into your <code>wally.toml</code> file.</p> <pre><code>[place]\nshared-packages = \"game.ReplicatedStorage.Packages\"\n\n[server-dependencies]\nEventTracker = \"dubit/event-tracker@^1\"\n</code></pre>"},{"location":"packages/event_tracker/#what-is-the-event-tracker-package","title":"What is the Event Tracker package?","text":"<p>The goal for this package is to provide developers with an easy way to create synced global events, some base features this library provides;</p> <ul> <li>Times for events are based off of the UTC time standard.<ul> <li>For example, if we want to offset time for an US Central event, we\u2019d set the UTC offset to -05:00</li> </ul> </li> <li>Allowing developers to get status updates on events.</li> </ul> <p>Warning</p> <p>The event tracker will NOT work in the background, developers must call the Start method in order to get the library to process times for events.</p>"},{"location":"packages/event_tracker/#examples","title":"Examples","text":"<p>The example seen below creates an \"EventName\" event, developers can implement functionality for these events by using the OnActivated and OnDeactivated lifecycle methods.</p> <pre><code>-- Server/.../Events/EventName.lua\n\nlocal Event = EventTracker.Event.new(\"EventName\", {\n    UTCStartTime = EventTracker.UTC.new({\n        Year = 2023,\n        Month = 5,\n        Day = 26,\n        Hour = 11,\n        Minute = 50,\n        Second = 0,\n    }):SetUTCOffset(EventTracker.TimeZone.BritishSummerTime),\n\n    UTCEndTime = EventTracker.UTC.new({\n        Year = 2023,\n        Month = 5,\n        Day = 26,\n        Hour = 11,\n        Minute = 59,\n        Second = 0,\n    }):SetUTCOffset(EventTracker.TimeZone.BritishSummerTime),\n\n    EventBadge = \"0000000\"\n})\n\nfunction Event:OnActivated()\n    awardPlayersEventBadge(self.EventBadge)\nend\n\nfunction Event:OnDeactivated()\n    doSomething()\nend\n\nreturn Event\n</code></pre> <p>The below example details how developers can connect to changes to event state from outside of the events lifecycle methods:</p> <pre><code>EventTracker.EventActivated:Connect(function(eventObject)\n\nend)\n\nEventTracker.EventDeactivated:Connect(function(eventObject)\n\nend)\n</code></pre>"},{"location":"packages/sequence_animator/","title":"Overview","text":"<p>SequenceAnimator is a package that implements a custom animation system for Roblox Models using KeyframeSequence objects as the source of animation data.</p> <p>It parses keyframe data which it uses to later update Motor6Ds and Bones on every frame to animate the model, it is used in places where Roblox Animations cannot be used, for ex. sharing animations across multiple experiences without making them publicly accessible.</p> <p>The goal of this package is to be similar to how Robloxes Animator functions, however it's not mature enough yet to have 1:1 feature parity, its feature set could expand over time as it is used in more projects and more complex scenarios.</p>"},{"location":"packages/sequence_animator/#adding-sequence-animator-to-a-project","title":"Adding Sequence Animator to a Project","text":"<p>To add the SequenceAnimator package to your project, add the following to your wally.toml file:</p> <pre><code>[dependencies]\nSequenceAnimator = \"dubit/sequence-animator@^0\"\n</code></pre>"},{"location":"packages/sequence_animator/#examples","title":"Examples","text":"<pre><code>local animator = SequenceAnimator.new(drill)\n\nlocal startTrack = animator:LoadSequence(drillStartKeyframeSequence)\nstartTrack.Looped = false\n\nlocal idleTrack = animator:LoadSequence(drillAnimationSource.Idle)\n\nstartTrack.Ended:Once(function()\n    idleTrack:Play()\nend)\n</code></pre>"},{"location":"packages/simple_store/","title":"Overview","text":""},{"location":"packages/totalizers/","title":"Overview","text":"<p>The community goals/totaliser tool is a tool that allows us to create some sort of value that can be written to,  and read from - from all Servers within a Roblox experience.</p> <p>This is useful in cases where you want to track something, for example - if you\u2019re in an shooter game and want to track how many kills all players have made throughout the lifetime of the experience, you\u2019re able to do that. Alongside this, we could use this value to award community members with free in-game items.</p>"}]}